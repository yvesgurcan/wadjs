!function(I){var g={};function C(n){if(g[n])return g[n].exports;var A=g[n]={i:n,l:!1,exports:{}};return I[n].call(A.exports,A,A.exports,C),A.l=!0,A.exports}C.m=I,C.c=g,C.d=function(I,g,n){C.o(I,g)||Object.defineProperty(I,g,{enumerable:!0,get:n})},C.r=function(I){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(I,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(I,"__esModule",{value:!0})},C.t=function(I,g){if(1&g&&(I=C(I)),8&g)return I;if(4&g&&"object"==typeof I&&I&&I.__esModule)return I;var n=Object.create(null);if(C.r(n),Object.defineProperty(n,"default",{enumerable:!0,value:I}),2&g&&"string"!=typeof I)for(var A in I)C.d(n,A,function(g){return I[g]}.bind(null,A));return n},C.n=function(I){var g=I&&I.__esModule?function(){return I.default}:function(){return I};return C.d(g,"a",g),g},C.o=function(I,g){return Object.prototype.hasOwnProperty.call(I,g)},C.p="dist/",C(C.s=4)}([function(module,exports,__webpack_require__){eval("module.exports = __webpack_require__(2);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMC5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9yZWdlbmVyYXRvci9pbmRleC5qcz9hMzRhIl0sInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcInJlZ2VuZXJhdG9yLXJ1bnRpbWVcIik7XG4iXSwibWFwcGluZ3MiOiJBQUFBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///0\n")},function(module,exports){eval('function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {\n  try {\n    var info = gen[key](arg);\n    var value = info.value;\n  } catch (error) {\n    reject(error);\n    return;\n  }\n\n  if (info.done) {\n    resolve(value);\n  } else {\n    Promise.resolve(value).then(_next, _throw);\n  }\n}\n\nfunction _asyncToGenerator(fn) {\n  return function () {\n    var self = this,\n        args = arguments;\n    return new Promise(function (resolve, reject) {\n      var gen = fn.apply(self, args);\n\n      function _next(value) {\n        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);\n      }\n\n      function _throw(err) {\n        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);\n      }\n\n      _next(undefined);\n    });\n  };\n}\n\nmodule.exports = _asyncToGenerator;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMS5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2FzeW5jVG9HZW5lcmF0b3IuanM/Yzk3MyJdLCJzb3VyY2VzQ29udGVudCI6WyJmdW5jdGlvbiBhc3luY0dlbmVyYXRvclN0ZXAoZ2VuLCByZXNvbHZlLCByZWplY3QsIF9uZXh0LCBfdGhyb3csIGtleSwgYXJnKSB7XG4gIHRyeSB7XG4gICAgdmFyIGluZm8gPSBnZW5ba2V5XShhcmcpO1xuICAgIHZhciB2YWx1ZSA9IGluZm8udmFsdWU7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgcmVqZWN0KGVycm9yKTtcbiAgICByZXR1cm47XG4gIH1cblxuICBpZiAoaW5mby5kb25lKSB7XG4gICAgcmVzb2x2ZSh2YWx1ZSk7XG4gIH0gZWxzZSB7XG4gICAgUHJvbWlzZS5yZXNvbHZlKHZhbHVlKS50aGVuKF9uZXh0LCBfdGhyb3cpO1xuICB9XG59XG5cbmZ1bmN0aW9uIF9hc3luY1RvR2VuZXJhdG9yKGZuKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzLFxuICAgICAgICBhcmdzID0gYXJndW1lbnRzO1xuICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICB2YXIgZ2VuID0gZm4uYXBwbHkoc2VsZiwgYXJncyk7XG5cbiAgICAgIGZ1bmN0aW9uIF9uZXh0KHZhbHVlKSB7XG4gICAgICAgIGFzeW5jR2VuZXJhdG9yU3RlcChnZW4sIHJlc29sdmUsIHJlamVjdCwgX25leHQsIF90aHJvdywgXCJuZXh0XCIsIHZhbHVlKTtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gX3Rocm93KGVycikge1xuICAgICAgICBhc3luY0dlbmVyYXRvclN0ZXAoZ2VuLCByZXNvbHZlLCByZWplY3QsIF9uZXh0LCBfdGhyb3csIFwidGhyb3dcIiwgZXJyKTtcbiAgICAgIH1cblxuICAgICAgX25leHQodW5kZWZpbmVkKTtcbiAgICB9KTtcbiAgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBfYXN5bmNUb0dlbmVyYXRvcjsiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///1\n')},function(module,exports,__webpack_require__){eval('/**\n * Copyright (c) 2014-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n// This method of obtaining a reference to the global object needs to be\n// kept identical to the way it is obtained in runtime.js\nvar g = (function() {\n  return this || (typeof self === "object" && self);\n})() || Function("return this")();\n\n// Use `getOwnPropertyNames` because not all browsers support calling\n// `hasOwnProperty` on the global `self` object in a worker. See #183.\nvar hadRuntime = g.regeneratorRuntime &&\n  Object.getOwnPropertyNames(g).indexOf("regeneratorRuntime") >= 0;\n\n// Save the old regeneratorRuntime in case it needs to be restored later.\nvar oldRuntime = hadRuntime && g.regeneratorRuntime;\n\n// Force reevalutation of runtime.js.\ng.regeneratorRuntime = undefined;\n\nmodule.exports = __webpack_require__(3);\n\nif (hadRuntime) {\n  // Restore the original runtime.\n  g.regeneratorRuntime = oldRuntime;\n} else {\n  // Remove the global property added by runtime.js.\n  try {\n    delete g.regeneratorRuntime;\n  } catch(e) {\n    g.regeneratorRuntime = undefined;\n  }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMi5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9yZWdlbmVyYXRvci1ydW50aW1lL3J1bnRpbWUtbW9kdWxlLmpzP2JiZGQiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTQtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuXG4vLyBUaGlzIG1ldGhvZCBvZiBvYnRhaW5pbmcgYSByZWZlcmVuY2UgdG8gdGhlIGdsb2JhbCBvYmplY3QgbmVlZHMgdG8gYmVcbi8vIGtlcHQgaWRlbnRpY2FsIHRvIHRoZSB3YXkgaXQgaXMgb2J0YWluZWQgaW4gcnVudGltZS5qc1xudmFyIGcgPSAoZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzIHx8ICh0eXBlb2Ygc2VsZiA9PT0gXCJvYmplY3RcIiAmJiBzZWxmKTtcbn0pKCkgfHwgRnVuY3Rpb24oXCJyZXR1cm4gdGhpc1wiKSgpO1xuXG4vLyBVc2UgYGdldE93blByb3BlcnR5TmFtZXNgIGJlY2F1c2Ugbm90IGFsbCBicm93c2VycyBzdXBwb3J0IGNhbGxpbmdcbi8vIGBoYXNPd25Qcm9wZXJ0eWAgb24gdGhlIGdsb2JhbCBgc2VsZmAgb2JqZWN0IGluIGEgd29ya2VyLiBTZWUgIzE4My5cbnZhciBoYWRSdW50aW1lID0gZy5yZWdlbmVyYXRvclJ1bnRpbWUgJiZcbiAgT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoZykuaW5kZXhPZihcInJlZ2VuZXJhdG9yUnVudGltZVwiKSA+PSAwO1xuXG4vLyBTYXZlIHRoZSBvbGQgcmVnZW5lcmF0b3JSdW50aW1lIGluIGNhc2UgaXQgbmVlZHMgdG8gYmUgcmVzdG9yZWQgbGF0ZXIuXG52YXIgb2xkUnVudGltZSA9IGhhZFJ1bnRpbWUgJiYgZy5yZWdlbmVyYXRvclJ1bnRpbWU7XG5cbi8vIEZvcmNlIHJlZXZhbHV0YXRpb24gb2YgcnVudGltZS5qcy5cbmcucmVnZW5lcmF0b3JSdW50aW1lID0gdW5kZWZpbmVkO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCIuL3J1bnRpbWVcIik7XG5cbmlmIChoYWRSdW50aW1lKSB7XG4gIC8vIFJlc3RvcmUgdGhlIG9yaWdpbmFsIHJ1bnRpbWUuXG4gIGcucmVnZW5lcmF0b3JSdW50aW1lID0gb2xkUnVudGltZTtcbn0gZWxzZSB7XG4gIC8vIFJlbW92ZSB0aGUgZ2xvYmFsIHByb3BlcnR5IGFkZGVkIGJ5IHJ1bnRpbWUuanMuXG4gIHRyeSB7XG4gICAgZGVsZXRlIGcucmVnZW5lcmF0b3JSdW50aW1lO1xuICB9IGNhdGNoKGUpIHtcbiAgICBnLnJlZ2VuZXJhdG9yUnVudGltZSA9IHVuZGVmaW5lZDtcbiAgfVxufVxuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///2\n')},function(module,exports){eval('/**\n * Copyright (c) 2014-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n!(function(global) {\n  "use strict";\n\n  var Op = Object.prototype;\n  var hasOwn = Op.hasOwnProperty;\n  var undefined; // More compressible than void 0.\n  var $Symbol = typeof Symbol === "function" ? Symbol : {};\n  var iteratorSymbol = $Symbol.iterator || "@@iterator";\n  var asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator";\n  var toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag";\n\n  var inModule = typeof module === "object";\n  var runtime = global.regeneratorRuntime;\n  if (runtime) {\n    if (inModule) {\n      // If regeneratorRuntime is defined globally and we\'re in a module,\n      // make the exports object identical to regeneratorRuntime.\n      module.exports = runtime;\n    }\n    // Don\'t bother evaluating the rest of this file if the runtime was\n    // already defined globally.\n    return;\n  }\n\n  // Define the runtime globally (as expected by generated code) as either\n  // module.exports (if we\'re in a module) or a new, empty object.\n  runtime = global.regeneratorRuntime = inModule ? module.exports : {};\n\n  function wrap(innerFn, outerFn, self, tryLocsList) {\n    // If outerFn provided and outerFn.prototype is a Generator, then outerFn.prototype instanceof Generator.\n    var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator;\n    var generator = Object.create(protoGenerator.prototype);\n    var context = new Context(tryLocsList || []);\n\n    // The ._invoke method unifies the implementations of the .next,\n    // .throw, and .return methods.\n    generator._invoke = makeInvokeMethod(innerFn, self, context);\n\n    return generator;\n  }\n  runtime.wrap = wrap;\n\n  // Try/catch helper to minimize deoptimizations. Returns a completion\n  // record like context.tryEntries[i].completion. This interface could\n  // have been (and was previously) designed to take a closure to be\n  // invoked without arguments, but in all the cases we care about we\n  // already have an existing method we want to call, so there\'s no need\n  // to create a new function object. We can even get away with assuming\n  // the method takes exactly one argument, since that happens to be true\n  // in every case, so we don\'t have to touch the arguments object. The\n  // only additional allocation required is the completion record, which\n  // has a stable shape and so hopefully should be cheap to allocate.\n  function tryCatch(fn, obj, arg) {\n    try {\n      return { type: "normal", arg: fn.call(obj, arg) };\n    } catch (err) {\n      return { type: "throw", arg: err };\n    }\n  }\n\n  var GenStateSuspendedStart = "suspendedStart";\n  var GenStateSuspendedYield = "suspendedYield";\n  var GenStateExecuting = "executing";\n  var GenStateCompleted = "completed";\n\n  // Returning this object from the innerFn has the same effect as\n  // breaking out of the dispatch switch statement.\n  var ContinueSentinel = {};\n\n  // Dummy constructor functions that we use as the .constructor and\n  // .constructor.prototype properties for functions that return Generator\n  // objects. For full spec compliance, you may wish to configure your\n  // minifier not to mangle the names of these two functions.\n  function Generator() {}\n  function GeneratorFunction() {}\n  function GeneratorFunctionPrototype() {}\n\n  // This is a polyfill for %IteratorPrototype% for environments that\n  // don\'t natively support it.\n  var IteratorPrototype = {};\n  IteratorPrototype[iteratorSymbol] = function () {\n    return this;\n  };\n\n  var getProto = Object.getPrototypeOf;\n  var NativeIteratorPrototype = getProto && getProto(getProto(values([])));\n  if (NativeIteratorPrototype &&\n      NativeIteratorPrototype !== Op &&\n      hasOwn.call(NativeIteratorPrototype, iteratorSymbol)) {\n    // This environment has a native %IteratorPrototype%; use it instead\n    // of the polyfill.\n    IteratorPrototype = NativeIteratorPrototype;\n  }\n\n  var Gp = GeneratorFunctionPrototype.prototype =\n    Generator.prototype = Object.create(IteratorPrototype);\n  GeneratorFunction.prototype = Gp.constructor = GeneratorFunctionPrototype;\n  GeneratorFunctionPrototype.constructor = GeneratorFunction;\n  GeneratorFunctionPrototype[toStringTagSymbol] =\n    GeneratorFunction.displayName = "GeneratorFunction";\n\n  // Helper for defining the .next, .throw, and .return methods of the\n  // Iterator interface in terms of a single ._invoke method.\n  function defineIteratorMethods(prototype) {\n    ["next", "throw", "return"].forEach(function(method) {\n      prototype[method] = function(arg) {\n        return this._invoke(method, arg);\n      };\n    });\n  }\n\n  runtime.isGeneratorFunction = function(genFun) {\n    var ctor = typeof genFun === "function" && genFun.constructor;\n    return ctor\n      ? ctor === GeneratorFunction ||\n        // For the native GeneratorFunction constructor, the best we can\n        // do is to check its .name property.\n        (ctor.displayName || ctor.name) === "GeneratorFunction"\n      : false;\n  };\n\n  runtime.mark = function(genFun) {\n    if (Object.setPrototypeOf) {\n      Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);\n    } else {\n      genFun.__proto__ = GeneratorFunctionPrototype;\n      if (!(toStringTagSymbol in genFun)) {\n        genFun[toStringTagSymbol] = "GeneratorFunction";\n      }\n    }\n    genFun.prototype = Object.create(Gp);\n    return genFun;\n  };\n\n  // Within the body of any async function, `await x` is transformed to\n  // `yield regeneratorRuntime.awrap(x)`, so that the runtime can test\n  // `hasOwn.call(value, "__await")` to determine if the yielded value is\n  // meant to be awaited.\n  runtime.awrap = function(arg) {\n    return { __await: arg };\n  };\n\n  function AsyncIterator(generator) {\n    function invoke(method, arg, resolve, reject) {\n      var record = tryCatch(generator[method], generator, arg);\n      if (record.type === "throw") {\n        reject(record.arg);\n      } else {\n        var result = record.arg;\n        var value = result.value;\n        if (value &&\n            typeof value === "object" &&\n            hasOwn.call(value, "__await")) {\n          return Promise.resolve(value.__await).then(function(value) {\n            invoke("next", value, resolve, reject);\n          }, function(err) {\n            invoke("throw", err, resolve, reject);\n          });\n        }\n\n        return Promise.resolve(value).then(function(unwrapped) {\n          // When a yielded Promise is resolved, its final value becomes\n          // the .value of the Promise<{value,done}> result for the\n          // current iteration.\n          result.value = unwrapped;\n          resolve(result);\n        }, function(error) {\n          // If a rejected Promise was yielded, throw the rejection back\n          // into the async generator function so it can be handled there.\n          return invoke("throw", error, resolve, reject);\n        });\n      }\n    }\n\n    var previousPromise;\n\n    function enqueue(method, arg) {\n      function callInvokeWithMethodAndArg() {\n        return new Promise(function(resolve, reject) {\n          invoke(method, arg, resolve, reject);\n        });\n      }\n\n      return previousPromise =\n        // If enqueue has been called before, then we want to wait until\n        // all previous Promises have been resolved before calling invoke,\n        // so that results are always delivered in the correct order. If\n        // enqueue has not been called before, then it is important to\n        // call invoke immediately, without waiting on a callback to fire,\n        // so that the async generator function has the opportunity to do\n        // any necessary setup in a predictable way. This predictability\n        // is why the Promise constructor synchronously invokes its\n        // executor callback, and why async functions synchronously\n        // execute code before the first await. Since we implement simple\n        // async functions in terms of async generators, it is especially\n        // important to get this right, even though it requires care.\n        previousPromise ? previousPromise.then(\n          callInvokeWithMethodAndArg,\n          // Avoid propagating failures to Promises returned by later\n          // invocations of the iterator.\n          callInvokeWithMethodAndArg\n        ) : callInvokeWithMethodAndArg();\n    }\n\n    // Define the unified helper method that is used to implement .next,\n    // .throw, and .return (see defineIteratorMethods).\n    this._invoke = enqueue;\n  }\n\n  defineIteratorMethods(AsyncIterator.prototype);\n  AsyncIterator.prototype[asyncIteratorSymbol] = function () {\n    return this;\n  };\n  runtime.AsyncIterator = AsyncIterator;\n\n  // Note that simple async functions are implemented on top of\n  // AsyncIterator objects; they just return a Promise for the value of\n  // the final result produced by the iterator.\n  runtime.async = function(innerFn, outerFn, self, tryLocsList) {\n    var iter = new AsyncIterator(\n      wrap(innerFn, outerFn, self, tryLocsList)\n    );\n\n    return runtime.isGeneratorFunction(outerFn)\n      ? iter // If outerFn is a generator, return the full iterator.\n      : iter.next().then(function(result) {\n          return result.done ? result.value : iter.next();\n        });\n  };\n\n  function makeInvokeMethod(innerFn, self, context) {\n    var state = GenStateSuspendedStart;\n\n    return function invoke(method, arg) {\n      if (state === GenStateExecuting) {\n        throw new Error("Generator is already running");\n      }\n\n      if (state === GenStateCompleted) {\n        if (method === "throw") {\n          throw arg;\n        }\n\n        // Be forgiving, per 25.3.3.3.3 of the spec:\n        // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume\n        return doneResult();\n      }\n\n      context.method = method;\n      context.arg = arg;\n\n      while (true) {\n        var delegate = context.delegate;\n        if (delegate) {\n          var delegateResult = maybeInvokeDelegate(delegate, context);\n          if (delegateResult) {\n            if (delegateResult === ContinueSentinel) continue;\n            return delegateResult;\n          }\n        }\n\n        if (context.method === "next") {\n          // Setting context._sent for legacy support of Babel\'s\n          // function.sent implementation.\n          context.sent = context._sent = context.arg;\n\n        } else if (context.method === "throw") {\n          if (state === GenStateSuspendedStart) {\n            state = GenStateCompleted;\n            throw context.arg;\n          }\n\n          context.dispatchException(context.arg);\n\n        } else if (context.method === "return") {\n          context.abrupt("return", context.arg);\n        }\n\n        state = GenStateExecuting;\n\n        var record = tryCatch(innerFn, self, context);\n        if (record.type === "normal") {\n          // If an exception is thrown from innerFn, we leave state ===\n          // GenStateExecuting and loop back for another invocation.\n          state = context.done\n            ? GenStateCompleted\n            : GenStateSuspendedYield;\n\n          if (record.arg === ContinueSentinel) {\n            continue;\n          }\n\n          return {\n            value: record.arg,\n            done: context.done\n          };\n\n        } else if (record.type === "throw") {\n          state = GenStateCompleted;\n          // Dispatch the exception by looping back around to the\n          // context.dispatchException(context.arg) call above.\n          context.method = "throw";\n          context.arg = record.arg;\n        }\n      }\n    };\n  }\n\n  // Call delegate.iterator[context.method](context.arg) and handle the\n  // result, either by returning a { value, done } result from the\n  // delegate iterator, or by modifying context.method and context.arg,\n  // setting context.delegate to null, and returning the ContinueSentinel.\n  function maybeInvokeDelegate(delegate, context) {\n    var method = delegate.iterator[context.method];\n    if (method === undefined) {\n      // A .throw or .return when the delegate iterator has no .throw\n      // method always terminates the yield* loop.\n      context.delegate = null;\n\n      if (context.method === "throw") {\n        if (delegate.iterator.return) {\n          // If the delegate iterator has a return method, give it a\n          // chance to clean up.\n          context.method = "return";\n          context.arg = undefined;\n          maybeInvokeDelegate(delegate, context);\n\n          if (context.method === "throw") {\n            // If maybeInvokeDelegate(context) changed context.method from\n            // "return" to "throw", let that override the TypeError below.\n            return ContinueSentinel;\n          }\n        }\n\n        context.method = "throw";\n        context.arg = new TypeError(\n          "The iterator does not provide a \'throw\' method");\n      }\n\n      return ContinueSentinel;\n    }\n\n    var record = tryCatch(method, delegate.iterator, context.arg);\n\n    if (record.type === "throw") {\n      context.method = "throw";\n      context.arg = record.arg;\n      context.delegate = null;\n      return ContinueSentinel;\n    }\n\n    var info = record.arg;\n\n    if (! info) {\n      context.method = "throw";\n      context.arg = new TypeError("iterator result is not an object");\n      context.delegate = null;\n      return ContinueSentinel;\n    }\n\n    if (info.done) {\n      // Assign the result of the finished delegate to the temporary\n      // variable specified by delegate.resultName (see delegateYield).\n      context[delegate.resultName] = info.value;\n\n      // Resume execution at the desired location (see delegateYield).\n      context.next = delegate.nextLoc;\n\n      // If context.method was "throw" but the delegate handled the\n      // exception, let the outer generator proceed normally. If\n      // context.method was "next", forget context.arg since it has been\n      // "consumed" by the delegate iterator. If context.method was\n      // "return", allow the original .return call to continue in the\n      // outer generator.\n      if (context.method !== "return") {\n        context.method = "next";\n        context.arg = undefined;\n      }\n\n    } else {\n      // Re-yield the result returned by the delegate method.\n      return info;\n    }\n\n    // The delegate iterator is finished, so forget it and continue with\n    // the outer generator.\n    context.delegate = null;\n    return ContinueSentinel;\n  }\n\n  // Define Generator.prototype.{next,throw,return} in terms of the\n  // unified ._invoke helper method.\n  defineIteratorMethods(Gp);\n\n  Gp[toStringTagSymbol] = "Generator";\n\n  // A Generator should always return itself as the iterator object when the\n  // @@iterator function is called on it. Some browsers\' implementations of the\n  // iterator prototype chain incorrectly implement this, causing the Generator\n  // object to not be returned from this call. This ensures that doesn\'t happen.\n  // See https://github.com/facebook/regenerator/issues/274 for more details.\n  Gp[iteratorSymbol] = function() {\n    return this;\n  };\n\n  Gp.toString = function() {\n    return "[object Generator]";\n  };\n\n  function pushTryEntry(locs) {\n    var entry = { tryLoc: locs[0] };\n\n    if (1 in locs) {\n      entry.catchLoc = locs[1];\n    }\n\n    if (2 in locs) {\n      entry.finallyLoc = locs[2];\n      entry.afterLoc = locs[3];\n    }\n\n    this.tryEntries.push(entry);\n  }\n\n  function resetTryEntry(entry) {\n    var record = entry.completion || {};\n    record.type = "normal";\n    delete record.arg;\n    entry.completion = record;\n  }\n\n  function Context(tryLocsList) {\n    // The root entry object (effectively a try statement without a catch\n    // or a finally block) gives us a place to store values thrown from\n    // locations where there is no enclosing try statement.\n    this.tryEntries = [{ tryLoc: "root" }];\n    tryLocsList.forEach(pushTryEntry, this);\n    this.reset(true);\n  }\n\n  runtime.keys = function(object) {\n    var keys = [];\n    for (var key in object) {\n      keys.push(key);\n    }\n    keys.reverse();\n\n    // Rather than returning an object with a next method, we keep\n    // things simple and return the next function itself.\n    return function next() {\n      while (keys.length) {\n        var key = keys.pop();\n        if (key in object) {\n          next.value = key;\n          next.done = false;\n          return next;\n        }\n      }\n\n      // To avoid creating an additional object, we just hang the .value\n      // and .done properties off the next function object itself. This\n      // also ensures that the minifier will not anonymize the function.\n      next.done = true;\n      return next;\n    };\n  };\n\n  function values(iterable) {\n    if (iterable) {\n      var iteratorMethod = iterable[iteratorSymbol];\n      if (iteratorMethod) {\n        return iteratorMethod.call(iterable);\n      }\n\n      if (typeof iterable.next === "function") {\n        return iterable;\n      }\n\n      if (!isNaN(iterable.length)) {\n        var i = -1, next = function next() {\n          while (++i < iterable.length) {\n            if (hasOwn.call(iterable, i)) {\n              next.value = iterable[i];\n              next.done = false;\n              return next;\n            }\n          }\n\n          next.value = undefined;\n          next.done = true;\n\n          return next;\n        };\n\n        return next.next = next;\n      }\n    }\n\n    // Return an iterator with no values.\n    return { next: doneResult };\n  }\n  runtime.values = values;\n\n  function doneResult() {\n    return { value: undefined, done: true };\n  }\n\n  Context.prototype = {\n    constructor: Context,\n\n    reset: function(skipTempReset) {\n      this.prev = 0;\n      this.next = 0;\n      // Resetting context._sent for legacy support of Babel\'s\n      // function.sent implementation.\n      this.sent = this._sent = undefined;\n      this.done = false;\n      this.delegate = null;\n\n      this.method = "next";\n      this.arg = undefined;\n\n      this.tryEntries.forEach(resetTryEntry);\n\n      if (!skipTempReset) {\n        for (var name in this) {\n          // Not sure about the optimal order of these conditions:\n          if (name.charAt(0) === "t" &&\n              hasOwn.call(this, name) &&\n              !isNaN(+name.slice(1))) {\n            this[name] = undefined;\n          }\n        }\n      }\n    },\n\n    stop: function() {\n      this.done = true;\n\n      var rootEntry = this.tryEntries[0];\n      var rootRecord = rootEntry.completion;\n      if (rootRecord.type === "throw") {\n        throw rootRecord.arg;\n      }\n\n      return this.rval;\n    },\n\n    dispatchException: function(exception) {\n      if (this.done) {\n        throw exception;\n      }\n\n      var context = this;\n      function handle(loc, caught) {\n        record.type = "throw";\n        record.arg = exception;\n        context.next = loc;\n\n        if (caught) {\n          // If the dispatched exception was caught by a catch block,\n          // then let that catch block handle the exception normally.\n          context.method = "next";\n          context.arg = undefined;\n        }\n\n        return !! caught;\n      }\n\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        var record = entry.completion;\n\n        if (entry.tryLoc === "root") {\n          // Exception thrown outside of any try block that could handle\n          // it, so set the completion value of the entire function to\n          // throw the exception.\n          return handle("end");\n        }\n\n        if (entry.tryLoc <= this.prev) {\n          var hasCatch = hasOwn.call(entry, "catchLoc");\n          var hasFinally = hasOwn.call(entry, "finallyLoc");\n\n          if (hasCatch && hasFinally) {\n            if (this.prev < entry.catchLoc) {\n              return handle(entry.catchLoc, true);\n            } else if (this.prev < entry.finallyLoc) {\n              return handle(entry.finallyLoc);\n            }\n\n          } else if (hasCatch) {\n            if (this.prev < entry.catchLoc) {\n              return handle(entry.catchLoc, true);\n            }\n\n          } else if (hasFinally) {\n            if (this.prev < entry.finallyLoc) {\n              return handle(entry.finallyLoc);\n            }\n\n          } else {\n            throw new Error("try statement without catch or finally");\n          }\n        }\n      }\n    },\n\n    abrupt: function(type, arg) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        if (entry.tryLoc <= this.prev &&\n            hasOwn.call(entry, "finallyLoc") &&\n            this.prev < entry.finallyLoc) {\n          var finallyEntry = entry;\n          break;\n        }\n      }\n\n      if (finallyEntry &&\n          (type === "break" ||\n           type === "continue") &&\n          finallyEntry.tryLoc <= arg &&\n          arg <= finallyEntry.finallyLoc) {\n        // Ignore the finally entry if control is not jumping to a\n        // location outside the try/catch block.\n        finallyEntry = null;\n      }\n\n      var record = finallyEntry ? finallyEntry.completion : {};\n      record.type = type;\n      record.arg = arg;\n\n      if (finallyEntry) {\n        this.method = "next";\n        this.next = finallyEntry.finallyLoc;\n        return ContinueSentinel;\n      }\n\n      return this.complete(record);\n    },\n\n    complete: function(record, afterLoc) {\n      if (record.type === "throw") {\n        throw record.arg;\n      }\n\n      if (record.type === "break" ||\n          record.type === "continue") {\n        this.next = record.arg;\n      } else if (record.type === "return") {\n        this.rval = this.arg = record.arg;\n        this.method = "return";\n        this.next = "end";\n      } else if (record.type === "normal" && afterLoc) {\n        this.next = afterLoc;\n      }\n\n      return ContinueSentinel;\n    },\n\n    finish: function(finallyLoc) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        if (entry.finallyLoc === finallyLoc) {\n          this.complete(entry.completion, entry.afterLoc);\n          resetTryEntry(entry);\n          return ContinueSentinel;\n        }\n      }\n    },\n\n    "catch": function(tryLoc) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        if (entry.tryLoc === tryLoc) {\n          var record = entry.completion;\n          if (record.type === "throw") {\n            var thrown = record.arg;\n            resetTryEntry(entry);\n          }\n          return thrown;\n        }\n      }\n\n      // The context.catch method must only be called with a location\n      // argument that corresponds to a known catch block.\n      throw new Error("illegal catch attempt");\n    },\n\n    delegateYield: function(iterable, resultName, nextLoc) {\n      this.delegate = {\n        iterator: values(iterable),\n        resultName: resultName,\n        nextLoc: nextLoc\n      };\n\n      if (this.method === "next") {\n        // Deliberately forget the last sent value so that we don\'t\n        // accidentally pass it on to the delegate.\n        this.arg = undefined;\n      }\n\n      return ContinueSentinel;\n    }\n  };\n})(\n  // In sloppy mode, unbound `this` refers to the global object, fallback to\n  // Function constructor if we\'re in global strict mode. That is sadly a form\n  // of indirect eval which violates Content Security Policy.\n  (function() {\n    return this || (typeof self === "object" && self);\n  })() || Function("return this")()\n);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9yZWdlbmVyYXRvci1ydW50aW1lL3J1bnRpbWUuanM/OTZjZiJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIENvcHlyaWdodCAoYykgMjAxNC1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG5cbiEoZnVuY3Rpb24oZ2xvYmFsKSB7XG4gIFwidXNlIHN0cmljdFwiO1xuXG4gIHZhciBPcCA9IE9iamVjdC5wcm90b3R5cGU7XG4gIHZhciBoYXNPd24gPSBPcC5oYXNPd25Qcm9wZXJ0eTtcbiAgdmFyIHVuZGVmaW5lZDsgLy8gTW9yZSBjb21wcmVzc2libGUgdGhhbiB2b2lkIDAuXG4gIHZhciAkU3ltYm9sID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiID8gU3ltYm9sIDoge307XG4gIHZhciBpdGVyYXRvclN5bWJvbCA9ICRTeW1ib2wuaXRlcmF0b3IgfHwgXCJAQGl0ZXJhdG9yXCI7XG4gIHZhciBhc3luY0l0ZXJhdG9yU3ltYm9sID0gJFN5bWJvbC5hc3luY0l0ZXJhdG9yIHx8IFwiQEBhc3luY0l0ZXJhdG9yXCI7XG4gIHZhciB0b1N0cmluZ1RhZ1N5bWJvbCA9ICRTeW1ib2wudG9TdHJpbmdUYWcgfHwgXCJAQHRvU3RyaW5nVGFnXCI7XG5cbiAgdmFyIGluTW9kdWxlID0gdHlwZW9mIG1vZHVsZSA9PT0gXCJvYmplY3RcIjtcbiAgdmFyIHJ1bnRpbWUgPSBnbG9iYWwucmVnZW5lcmF0b3JSdW50aW1lO1xuICBpZiAocnVudGltZSkge1xuICAgIGlmIChpbk1vZHVsZSkge1xuICAgICAgLy8gSWYgcmVnZW5lcmF0b3JSdW50aW1lIGlzIGRlZmluZWQgZ2xvYmFsbHkgYW5kIHdlJ3JlIGluIGEgbW9kdWxlLFxuICAgICAgLy8gbWFrZSB0aGUgZXhwb3J0cyBvYmplY3QgaWRlbnRpY2FsIHRvIHJlZ2VuZXJhdG9yUnVudGltZS5cbiAgICAgIG1vZHVsZS5leHBvcnRzID0gcnVudGltZTtcbiAgICB9XG4gICAgLy8gRG9uJ3QgYm90aGVyIGV2YWx1YXRpbmcgdGhlIHJlc3Qgb2YgdGhpcyBmaWxlIGlmIHRoZSBydW50aW1lIHdhc1xuICAgIC8vIGFscmVhZHkgZGVmaW5lZCBnbG9iYWxseS5cbiAgICByZXR1cm47XG4gIH1cblxuICAvLyBEZWZpbmUgdGhlIHJ1bnRpbWUgZ2xvYmFsbHkgKGFzIGV4cGVjdGVkIGJ5IGdlbmVyYXRlZCBjb2RlKSBhcyBlaXRoZXJcbiAgLy8gbW9kdWxlLmV4cG9ydHMgKGlmIHdlJ3JlIGluIGEgbW9kdWxlKSBvciBhIG5ldywgZW1wdHkgb2JqZWN0LlxuICBydW50aW1lID0gZ2xvYmFsLnJlZ2VuZXJhdG9yUnVudGltZSA9IGluTW9kdWxlID8gbW9kdWxlLmV4cG9ydHMgOiB7fTtcblxuICBmdW5jdGlvbiB3cmFwKGlubmVyRm4sIG91dGVyRm4sIHNlbGYsIHRyeUxvY3NMaXN0KSB7XG4gICAgLy8gSWYgb3V0ZXJGbiBwcm92aWRlZCBhbmQgb3V0ZXJGbi5wcm90b3R5cGUgaXMgYSBHZW5lcmF0b3IsIHRoZW4gb3V0ZXJGbi5wcm90b3R5cGUgaW5zdGFuY2VvZiBHZW5lcmF0b3IuXG4gICAgdmFyIHByb3RvR2VuZXJhdG9yID0gb3V0ZXJGbiAmJiBvdXRlckZuLnByb3RvdHlwZSBpbnN0YW5jZW9mIEdlbmVyYXRvciA/IG91dGVyRm4gOiBHZW5lcmF0b3I7XG4gICAgdmFyIGdlbmVyYXRvciA9IE9iamVjdC5jcmVhdGUocHJvdG9HZW5lcmF0b3IucHJvdG90eXBlKTtcbiAgICB2YXIgY29udGV4dCA9IG5ldyBDb250ZXh0KHRyeUxvY3NMaXN0IHx8IFtdKTtcblxuICAgIC8vIFRoZSAuX2ludm9rZSBtZXRob2QgdW5pZmllcyB0aGUgaW1wbGVtZW50YXRpb25zIG9mIHRoZSAubmV4dCxcbiAgICAvLyAudGhyb3csIGFuZCAucmV0dXJuIG1ldGhvZHMuXG4gICAgZ2VuZXJhdG9yLl9pbnZva2UgPSBtYWtlSW52b2tlTWV0aG9kKGlubmVyRm4sIHNlbGYsIGNvbnRleHQpO1xuXG4gICAgcmV0dXJuIGdlbmVyYXRvcjtcbiAgfVxuICBydW50aW1lLndyYXAgPSB3cmFwO1xuXG4gIC8vIFRyeS9jYXRjaCBoZWxwZXIgdG8gbWluaW1pemUgZGVvcHRpbWl6YXRpb25zLiBSZXR1cm5zIGEgY29tcGxldGlvblxuICAvLyByZWNvcmQgbGlrZSBjb250ZXh0LnRyeUVudHJpZXNbaV0uY29tcGxldGlvbi4gVGhpcyBpbnRlcmZhY2UgY291bGRcbiAgLy8gaGF2ZSBiZWVuIChhbmQgd2FzIHByZXZpb3VzbHkpIGRlc2lnbmVkIHRvIHRha2UgYSBjbG9zdXJlIHRvIGJlXG4gIC8vIGludm9rZWQgd2l0aG91dCBhcmd1bWVudHMsIGJ1dCBpbiBhbGwgdGhlIGNhc2VzIHdlIGNhcmUgYWJvdXQgd2VcbiAgLy8gYWxyZWFkeSBoYXZlIGFuIGV4aXN0aW5nIG1ldGhvZCB3ZSB3YW50IHRvIGNhbGwsIHNvIHRoZXJlJ3Mgbm8gbmVlZFxuICAvLyB0byBjcmVhdGUgYSBuZXcgZnVuY3Rpb24gb2JqZWN0LiBXZSBjYW4gZXZlbiBnZXQgYXdheSB3aXRoIGFzc3VtaW5nXG4gIC8vIHRoZSBtZXRob2QgdGFrZXMgZXhhY3RseSBvbmUgYXJndW1lbnQsIHNpbmNlIHRoYXQgaGFwcGVucyB0byBiZSB0cnVlXG4gIC8vIGluIGV2ZXJ5IGNhc2UsIHNvIHdlIGRvbid0IGhhdmUgdG8gdG91Y2ggdGhlIGFyZ3VtZW50cyBvYmplY3QuIFRoZVxuICAvLyBvbmx5IGFkZGl0aW9uYWwgYWxsb2NhdGlvbiByZXF1aXJlZCBpcyB0aGUgY29tcGxldGlvbiByZWNvcmQsIHdoaWNoXG4gIC8vIGhhcyBhIHN0YWJsZSBzaGFwZSBhbmQgc28gaG9wZWZ1bGx5IHNob3VsZCBiZSBjaGVhcCB0byBhbGxvY2F0ZS5cbiAgZnVuY3Rpb24gdHJ5Q2F0Y2goZm4sIG9iaiwgYXJnKSB7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiB7IHR5cGU6IFwibm9ybWFsXCIsIGFyZzogZm4uY2FsbChvYmosIGFyZykgfTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIHJldHVybiB7IHR5cGU6IFwidGhyb3dcIiwgYXJnOiBlcnIgfTtcbiAgICB9XG4gIH1cblxuICB2YXIgR2VuU3RhdGVTdXNwZW5kZWRTdGFydCA9IFwic3VzcGVuZGVkU3RhcnRcIjtcbiAgdmFyIEdlblN0YXRlU3VzcGVuZGVkWWllbGQgPSBcInN1c3BlbmRlZFlpZWxkXCI7XG4gIHZhciBHZW5TdGF0ZUV4ZWN1dGluZyA9IFwiZXhlY3V0aW5nXCI7XG4gIHZhciBHZW5TdGF0ZUNvbXBsZXRlZCA9IFwiY29tcGxldGVkXCI7XG5cbiAgLy8gUmV0dXJuaW5nIHRoaXMgb2JqZWN0IGZyb20gdGhlIGlubmVyRm4gaGFzIHRoZSBzYW1lIGVmZmVjdCBhc1xuICAvLyBicmVha2luZyBvdXQgb2YgdGhlIGRpc3BhdGNoIHN3aXRjaCBzdGF0ZW1lbnQuXG4gIHZhciBDb250aW51ZVNlbnRpbmVsID0ge307XG5cbiAgLy8gRHVtbXkgY29uc3RydWN0b3IgZnVuY3Rpb25zIHRoYXQgd2UgdXNlIGFzIHRoZSAuY29uc3RydWN0b3IgYW5kXG4gIC8vIC5jb25zdHJ1Y3Rvci5wcm90b3R5cGUgcHJvcGVydGllcyBmb3IgZnVuY3Rpb25zIHRoYXQgcmV0dXJuIEdlbmVyYXRvclxuICAvLyBvYmplY3RzLiBGb3IgZnVsbCBzcGVjIGNvbXBsaWFuY2UsIHlvdSBtYXkgd2lzaCB0byBjb25maWd1cmUgeW91clxuICAvLyBtaW5pZmllciBub3QgdG8gbWFuZ2xlIHRoZSBuYW1lcyBvZiB0aGVzZSB0d28gZnVuY3Rpb25zLlxuICBmdW5jdGlvbiBHZW5lcmF0b3IoKSB7fVxuICBmdW5jdGlvbiBHZW5lcmF0b3JGdW5jdGlvbigpIHt9XG4gIGZ1bmN0aW9uIEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlKCkge31cblxuICAvLyBUaGlzIGlzIGEgcG9seWZpbGwgZm9yICVJdGVyYXRvclByb3RvdHlwZSUgZm9yIGVudmlyb25tZW50cyB0aGF0XG4gIC8vIGRvbid0IG5hdGl2ZWx5IHN1cHBvcnQgaXQuXG4gIHZhciBJdGVyYXRvclByb3RvdHlwZSA9IHt9O1xuICBJdGVyYXRvclByb3RvdHlwZVtpdGVyYXRvclN5bWJvbF0gPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgdmFyIGdldFByb3RvID0gT2JqZWN0LmdldFByb3RvdHlwZU9mO1xuICB2YXIgTmF0aXZlSXRlcmF0b3JQcm90b3R5cGUgPSBnZXRQcm90byAmJiBnZXRQcm90byhnZXRQcm90byh2YWx1ZXMoW10pKSk7XG4gIGlmIChOYXRpdmVJdGVyYXRvclByb3RvdHlwZSAmJlxuICAgICAgTmF0aXZlSXRlcmF0b3JQcm90b3R5cGUgIT09IE9wICYmXG4gICAgICBoYXNPd24uY2FsbChOYXRpdmVJdGVyYXRvclByb3RvdHlwZSwgaXRlcmF0b3JTeW1ib2wpKSB7XG4gICAgLy8gVGhpcyBlbnZpcm9ubWVudCBoYXMgYSBuYXRpdmUgJUl0ZXJhdG9yUHJvdG90eXBlJTsgdXNlIGl0IGluc3RlYWRcbiAgICAvLyBvZiB0aGUgcG9seWZpbGwuXG4gICAgSXRlcmF0b3JQcm90b3R5cGUgPSBOYXRpdmVJdGVyYXRvclByb3RvdHlwZTtcbiAgfVxuXG4gIHZhciBHcCA9IEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlLnByb3RvdHlwZSA9XG4gICAgR2VuZXJhdG9yLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoSXRlcmF0b3JQcm90b3R5cGUpO1xuICBHZW5lcmF0b3JGdW5jdGlvbi5wcm90b3R5cGUgPSBHcC5jb25zdHJ1Y3RvciA9IEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlO1xuICBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IEdlbmVyYXRvckZ1bmN0aW9uO1xuICBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZVt0b1N0cmluZ1RhZ1N5bWJvbF0gPVxuICAgIEdlbmVyYXRvckZ1bmN0aW9uLmRpc3BsYXlOYW1lID0gXCJHZW5lcmF0b3JGdW5jdGlvblwiO1xuXG4gIC8vIEhlbHBlciBmb3IgZGVmaW5pbmcgdGhlIC5uZXh0LCAudGhyb3csIGFuZCAucmV0dXJuIG1ldGhvZHMgb2YgdGhlXG4gIC8vIEl0ZXJhdG9yIGludGVyZmFjZSBpbiB0ZXJtcyBvZiBhIHNpbmdsZSAuX2ludm9rZSBtZXRob2QuXG4gIGZ1bmN0aW9uIGRlZmluZUl0ZXJhdG9yTWV0aG9kcyhwcm90b3R5cGUpIHtcbiAgICBbXCJuZXh0XCIsIFwidGhyb3dcIiwgXCJyZXR1cm5cIl0uZm9yRWFjaChmdW5jdGlvbihtZXRob2QpIHtcbiAgICAgIHByb3RvdHlwZVttZXRob2RdID0gZnVuY3Rpb24oYXJnKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9pbnZva2UobWV0aG9kLCBhcmcpO1xuICAgICAgfTtcbiAgICB9KTtcbiAgfVxuXG4gIHJ1bnRpbWUuaXNHZW5lcmF0b3JGdW5jdGlvbiA9IGZ1bmN0aW9uKGdlbkZ1bikge1xuICAgIHZhciBjdG9yID0gdHlwZW9mIGdlbkZ1biA9PT0gXCJmdW5jdGlvblwiICYmIGdlbkZ1bi5jb25zdHJ1Y3RvcjtcbiAgICByZXR1cm4gY3RvclxuICAgICAgPyBjdG9yID09PSBHZW5lcmF0b3JGdW5jdGlvbiB8fFxuICAgICAgICAvLyBGb3IgdGhlIG5hdGl2ZSBHZW5lcmF0b3JGdW5jdGlvbiBjb25zdHJ1Y3RvciwgdGhlIGJlc3Qgd2UgY2FuXG4gICAgICAgIC8vIGRvIGlzIHRvIGNoZWNrIGl0cyAubmFtZSBwcm9wZXJ0eS5cbiAgICAgICAgKGN0b3IuZGlzcGxheU5hbWUgfHwgY3Rvci5uYW1lKSA9PT0gXCJHZW5lcmF0b3JGdW5jdGlvblwiXG4gICAgICA6IGZhbHNlO1xuICB9O1xuXG4gIHJ1bnRpbWUubWFyayA9IGZ1bmN0aW9uKGdlbkZ1bikge1xuICAgIGlmIChPYmplY3Quc2V0UHJvdG90eXBlT2YpIHtcbiAgICAgIE9iamVjdC5zZXRQcm90b3R5cGVPZihnZW5GdW4sIEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZ2VuRnVuLl9fcHJvdG9fXyA9IEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlO1xuICAgICAgaWYgKCEodG9TdHJpbmdUYWdTeW1ib2wgaW4gZ2VuRnVuKSkge1xuICAgICAgICBnZW5GdW5bdG9TdHJpbmdUYWdTeW1ib2xdID0gXCJHZW5lcmF0b3JGdW5jdGlvblwiO1xuICAgICAgfVxuICAgIH1cbiAgICBnZW5GdW4ucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShHcCk7XG4gICAgcmV0dXJuIGdlbkZ1bjtcbiAgfTtcblxuICAvLyBXaXRoaW4gdGhlIGJvZHkgb2YgYW55IGFzeW5jIGZ1bmN0aW9uLCBgYXdhaXQgeGAgaXMgdHJhbnNmb3JtZWQgdG9cbiAgLy8gYHlpZWxkIHJlZ2VuZXJhdG9yUnVudGltZS5hd3JhcCh4KWAsIHNvIHRoYXQgdGhlIHJ1bnRpbWUgY2FuIHRlc3RcbiAgLy8gYGhhc093bi5jYWxsKHZhbHVlLCBcIl9fYXdhaXRcIilgIHRvIGRldGVybWluZSBpZiB0aGUgeWllbGRlZCB2YWx1ZSBpc1xuICAvLyBtZWFudCB0byBiZSBhd2FpdGVkLlxuICBydW50aW1lLmF3cmFwID0gZnVuY3Rpb24oYXJnKSB7XG4gICAgcmV0dXJuIHsgX19hd2FpdDogYXJnIH07XG4gIH07XG5cbiAgZnVuY3Rpb24gQXN5bmNJdGVyYXRvcihnZW5lcmF0b3IpIHtcbiAgICBmdW5jdGlvbiBpbnZva2UobWV0aG9kLCBhcmcsIHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgdmFyIHJlY29yZCA9IHRyeUNhdGNoKGdlbmVyYXRvclttZXRob2RdLCBnZW5lcmF0b3IsIGFyZyk7XG4gICAgICBpZiAocmVjb3JkLnR5cGUgPT09IFwidGhyb3dcIikge1xuICAgICAgICByZWplY3QocmVjb3JkLmFyZyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgcmVzdWx0ID0gcmVjb3JkLmFyZztcbiAgICAgICAgdmFyIHZhbHVlID0gcmVzdWx0LnZhbHVlO1xuICAgICAgICBpZiAodmFsdWUgJiZcbiAgICAgICAgICAgIHR5cGVvZiB2YWx1ZSA9PT0gXCJvYmplY3RcIiAmJlxuICAgICAgICAgICAgaGFzT3duLmNhbGwodmFsdWUsIFwiX19hd2FpdFwiKSkge1xuICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUodmFsdWUuX19hd2FpdCkudGhlbihmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICAgICAgaW52b2tlKFwibmV4dFwiLCB2YWx1ZSwgcmVzb2x2ZSwgcmVqZWN0KTtcbiAgICAgICAgICB9LCBmdW5jdGlvbihlcnIpIHtcbiAgICAgICAgICAgIGludm9rZShcInRocm93XCIsIGVyciwgcmVzb2x2ZSwgcmVqZWN0KTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUodmFsdWUpLnRoZW4oZnVuY3Rpb24odW53cmFwcGVkKSB7XG4gICAgICAgICAgLy8gV2hlbiBhIHlpZWxkZWQgUHJvbWlzZSBpcyByZXNvbHZlZCwgaXRzIGZpbmFsIHZhbHVlIGJlY29tZXNcbiAgICAgICAgICAvLyB0aGUgLnZhbHVlIG9mIHRoZSBQcm9taXNlPHt2YWx1ZSxkb25lfT4gcmVzdWx0IGZvciB0aGVcbiAgICAgICAgICAvLyBjdXJyZW50IGl0ZXJhdGlvbi5cbiAgICAgICAgICByZXN1bHQudmFsdWUgPSB1bndyYXBwZWQ7XG4gICAgICAgICAgcmVzb2x2ZShyZXN1bHQpO1xuICAgICAgICB9LCBmdW5jdGlvbihlcnJvcikge1xuICAgICAgICAgIC8vIElmIGEgcmVqZWN0ZWQgUHJvbWlzZSB3YXMgeWllbGRlZCwgdGhyb3cgdGhlIHJlamVjdGlvbiBiYWNrXG4gICAgICAgICAgLy8gaW50byB0aGUgYXN5bmMgZ2VuZXJhdG9yIGZ1bmN0aW9uIHNvIGl0IGNhbiBiZSBoYW5kbGVkIHRoZXJlLlxuICAgICAgICAgIHJldHVybiBpbnZva2UoXCJ0aHJvd1wiLCBlcnJvciwgcmVzb2x2ZSwgcmVqZWN0KTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIHByZXZpb3VzUHJvbWlzZTtcblxuICAgIGZ1bmN0aW9uIGVucXVldWUobWV0aG9kLCBhcmcpIHtcbiAgICAgIGZ1bmN0aW9uIGNhbGxJbnZva2VXaXRoTWV0aG9kQW5kQXJnKCkge1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgICAgaW52b2tlKG1ldGhvZCwgYXJnLCByZXNvbHZlLCByZWplY3QpO1xuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHByZXZpb3VzUHJvbWlzZSA9XG4gICAgICAgIC8vIElmIGVucXVldWUgaGFzIGJlZW4gY2FsbGVkIGJlZm9yZSwgdGhlbiB3ZSB3YW50IHRvIHdhaXQgdW50aWxcbiAgICAgICAgLy8gYWxsIHByZXZpb3VzIFByb21pc2VzIGhhdmUgYmVlbiByZXNvbHZlZCBiZWZvcmUgY2FsbGluZyBpbnZva2UsXG4gICAgICAgIC8vIHNvIHRoYXQgcmVzdWx0cyBhcmUgYWx3YXlzIGRlbGl2ZXJlZCBpbiB0aGUgY29ycmVjdCBvcmRlci4gSWZcbiAgICAgICAgLy8gZW5xdWV1ZSBoYXMgbm90IGJlZW4gY2FsbGVkIGJlZm9yZSwgdGhlbiBpdCBpcyBpbXBvcnRhbnQgdG9cbiAgICAgICAgLy8gY2FsbCBpbnZva2UgaW1tZWRpYXRlbHksIHdpdGhvdXQgd2FpdGluZyBvbiBhIGNhbGxiYWNrIHRvIGZpcmUsXG4gICAgICAgIC8vIHNvIHRoYXQgdGhlIGFzeW5jIGdlbmVyYXRvciBmdW5jdGlvbiBoYXMgdGhlIG9wcG9ydHVuaXR5IHRvIGRvXG4gICAgICAgIC8vIGFueSBuZWNlc3Nhcnkgc2V0dXAgaW4gYSBwcmVkaWN0YWJsZSB3YXkuIFRoaXMgcHJlZGljdGFiaWxpdHlcbiAgICAgICAgLy8gaXMgd2h5IHRoZSBQcm9taXNlIGNvbnN0cnVjdG9yIHN5bmNocm9ub3VzbHkgaW52b2tlcyBpdHNcbiAgICAgICAgLy8gZXhlY3V0b3IgY2FsbGJhY2ssIGFuZCB3aHkgYXN5bmMgZnVuY3Rpb25zIHN5bmNocm9ub3VzbHlcbiAgICAgICAgLy8gZXhlY3V0ZSBjb2RlIGJlZm9yZSB0aGUgZmlyc3QgYXdhaXQuIFNpbmNlIHdlIGltcGxlbWVudCBzaW1wbGVcbiAgICAgICAgLy8gYXN5bmMgZnVuY3Rpb25zIGluIHRlcm1zIG9mIGFzeW5jIGdlbmVyYXRvcnMsIGl0IGlzIGVzcGVjaWFsbHlcbiAgICAgICAgLy8gaW1wb3J0YW50IHRvIGdldCB0aGlzIHJpZ2h0LCBldmVuIHRob3VnaCBpdCByZXF1aXJlcyBjYXJlLlxuICAgICAgICBwcmV2aW91c1Byb21pc2UgPyBwcmV2aW91c1Byb21pc2UudGhlbihcbiAgICAgICAgICBjYWxsSW52b2tlV2l0aE1ldGhvZEFuZEFyZyxcbiAgICAgICAgICAvLyBBdm9pZCBwcm9wYWdhdGluZyBmYWlsdXJlcyB0byBQcm9taXNlcyByZXR1cm5lZCBieSBsYXRlclxuICAgICAgICAgIC8vIGludm9jYXRpb25zIG9mIHRoZSBpdGVyYXRvci5cbiAgICAgICAgICBjYWxsSW52b2tlV2l0aE1ldGhvZEFuZEFyZ1xuICAgICAgICApIDogY2FsbEludm9rZVdpdGhNZXRob2RBbmRBcmcoKTtcbiAgICB9XG5cbiAgICAvLyBEZWZpbmUgdGhlIHVuaWZpZWQgaGVscGVyIG1ldGhvZCB0aGF0IGlzIHVzZWQgdG8gaW1wbGVtZW50IC5uZXh0LFxuICAgIC8vIC50aHJvdywgYW5kIC5yZXR1cm4gKHNlZSBkZWZpbmVJdGVyYXRvck1ldGhvZHMpLlxuICAgIHRoaXMuX2ludm9rZSA9IGVucXVldWU7XG4gIH1cblxuICBkZWZpbmVJdGVyYXRvck1ldGhvZHMoQXN5bmNJdGVyYXRvci5wcm90b3R5cGUpO1xuICBBc3luY0l0ZXJhdG9yLnByb3RvdHlwZVthc3luY0l0ZXJhdG9yU3ltYm9sXSA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcbiAgcnVudGltZS5Bc3luY0l0ZXJhdG9yID0gQXN5bmNJdGVyYXRvcjtcblxuICAvLyBOb3RlIHRoYXQgc2ltcGxlIGFzeW5jIGZ1bmN0aW9ucyBhcmUgaW1wbGVtZW50ZWQgb24gdG9wIG9mXG4gIC8vIEFzeW5jSXRlcmF0b3Igb2JqZWN0czsgdGhleSBqdXN0IHJldHVybiBhIFByb21pc2UgZm9yIHRoZSB2YWx1ZSBvZlxuICAvLyB0aGUgZmluYWwgcmVzdWx0IHByb2R1Y2VkIGJ5IHRoZSBpdGVyYXRvci5cbiAgcnVudGltZS5hc3luYyA9IGZ1bmN0aW9uKGlubmVyRm4sIG91dGVyRm4sIHNlbGYsIHRyeUxvY3NMaXN0KSB7XG4gICAgdmFyIGl0ZXIgPSBuZXcgQXN5bmNJdGVyYXRvcihcbiAgICAgIHdyYXAoaW5uZXJGbiwgb3V0ZXJGbiwgc2VsZiwgdHJ5TG9jc0xpc3QpXG4gICAgKTtcblxuICAgIHJldHVybiBydW50aW1lLmlzR2VuZXJhdG9yRnVuY3Rpb24ob3V0ZXJGbilcbiAgICAgID8gaXRlciAvLyBJZiBvdXRlckZuIGlzIGEgZ2VuZXJhdG9yLCByZXR1cm4gdGhlIGZ1bGwgaXRlcmF0b3IuXG4gICAgICA6IGl0ZXIubmV4dCgpLnRoZW4oZnVuY3Rpb24ocmVzdWx0KSB7XG4gICAgICAgICAgcmV0dXJuIHJlc3VsdC5kb25lID8gcmVzdWx0LnZhbHVlIDogaXRlci5uZXh0KCk7XG4gICAgICAgIH0pO1xuICB9O1xuXG4gIGZ1bmN0aW9uIG1ha2VJbnZva2VNZXRob2QoaW5uZXJGbiwgc2VsZiwgY29udGV4dCkge1xuICAgIHZhciBzdGF0ZSA9IEdlblN0YXRlU3VzcGVuZGVkU3RhcnQ7XG5cbiAgICByZXR1cm4gZnVuY3Rpb24gaW52b2tlKG1ldGhvZCwgYXJnKSB7XG4gICAgICBpZiAoc3RhdGUgPT09IEdlblN0YXRlRXhlY3V0aW5nKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkdlbmVyYXRvciBpcyBhbHJlYWR5IHJ1bm5pbmdcIik7XG4gICAgICB9XG5cbiAgICAgIGlmIChzdGF0ZSA9PT0gR2VuU3RhdGVDb21wbGV0ZWQpIHtcbiAgICAgICAgaWYgKG1ldGhvZCA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgICAgdGhyb3cgYXJnO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQmUgZm9yZ2l2aW5nLCBwZXIgMjUuMy4zLjMuMyBvZiB0aGUgc3BlYzpcbiAgICAgICAgLy8gaHR0cHM6Ly9wZW9wbGUubW96aWxsYS5vcmcvfmpvcmVuZG9yZmYvZXM2LWRyYWZ0Lmh0bWwjc2VjLWdlbmVyYXRvcnJlc3VtZVxuICAgICAgICByZXR1cm4gZG9uZVJlc3VsdCgpO1xuICAgICAgfVxuXG4gICAgICBjb250ZXh0Lm1ldGhvZCA9IG1ldGhvZDtcbiAgICAgIGNvbnRleHQuYXJnID0gYXJnO1xuXG4gICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICB2YXIgZGVsZWdhdGUgPSBjb250ZXh0LmRlbGVnYXRlO1xuICAgICAgICBpZiAoZGVsZWdhdGUpIHtcbiAgICAgICAgICB2YXIgZGVsZWdhdGVSZXN1bHQgPSBtYXliZUludm9rZURlbGVnYXRlKGRlbGVnYXRlLCBjb250ZXh0KTtcbiAgICAgICAgICBpZiAoZGVsZWdhdGVSZXN1bHQpIHtcbiAgICAgICAgICAgIGlmIChkZWxlZ2F0ZVJlc3VsdCA9PT0gQ29udGludWVTZW50aW5lbCkgY29udGludWU7XG4gICAgICAgICAgICByZXR1cm4gZGVsZWdhdGVSZXN1bHQ7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGNvbnRleHQubWV0aG9kID09PSBcIm5leHRcIikge1xuICAgICAgICAgIC8vIFNldHRpbmcgY29udGV4dC5fc2VudCBmb3IgbGVnYWN5IHN1cHBvcnQgb2YgQmFiZWwnc1xuICAgICAgICAgIC8vIGZ1bmN0aW9uLnNlbnQgaW1wbGVtZW50YXRpb24uXG4gICAgICAgICAgY29udGV4dC5zZW50ID0gY29udGV4dC5fc2VudCA9IGNvbnRleHQuYXJnO1xuXG4gICAgICAgIH0gZWxzZSBpZiAoY29udGV4dC5tZXRob2QgPT09IFwidGhyb3dcIikge1xuICAgICAgICAgIGlmIChzdGF0ZSA9PT0gR2VuU3RhdGVTdXNwZW5kZWRTdGFydCkge1xuICAgICAgICAgICAgc3RhdGUgPSBHZW5TdGF0ZUNvbXBsZXRlZDtcbiAgICAgICAgICAgIHRocm93IGNvbnRleHQuYXJnO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGNvbnRleHQuZGlzcGF0Y2hFeGNlcHRpb24oY29udGV4dC5hcmcpO1xuXG4gICAgICAgIH0gZWxzZSBpZiAoY29udGV4dC5tZXRob2QgPT09IFwicmV0dXJuXCIpIHtcbiAgICAgICAgICBjb250ZXh0LmFicnVwdChcInJldHVyblwiLCBjb250ZXh0LmFyZyk7XG4gICAgICAgIH1cblxuICAgICAgICBzdGF0ZSA9IEdlblN0YXRlRXhlY3V0aW5nO1xuXG4gICAgICAgIHZhciByZWNvcmQgPSB0cnlDYXRjaChpbm5lckZuLCBzZWxmLCBjb250ZXh0KTtcbiAgICAgICAgaWYgKHJlY29yZC50eXBlID09PSBcIm5vcm1hbFwiKSB7XG4gICAgICAgICAgLy8gSWYgYW4gZXhjZXB0aW9uIGlzIHRocm93biBmcm9tIGlubmVyRm4sIHdlIGxlYXZlIHN0YXRlID09PVxuICAgICAgICAgIC8vIEdlblN0YXRlRXhlY3V0aW5nIGFuZCBsb29wIGJhY2sgZm9yIGFub3RoZXIgaW52b2NhdGlvbi5cbiAgICAgICAgICBzdGF0ZSA9IGNvbnRleHQuZG9uZVxuICAgICAgICAgICAgPyBHZW5TdGF0ZUNvbXBsZXRlZFxuICAgICAgICAgICAgOiBHZW5TdGF0ZVN1c3BlbmRlZFlpZWxkO1xuXG4gICAgICAgICAgaWYgKHJlY29yZC5hcmcgPT09IENvbnRpbnVlU2VudGluZWwpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB2YWx1ZTogcmVjb3JkLmFyZyxcbiAgICAgICAgICAgIGRvbmU6IGNvbnRleHQuZG9uZVxuICAgICAgICAgIH07XG5cbiAgICAgICAgfSBlbHNlIGlmIChyZWNvcmQudHlwZSA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgICAgc3RhdGUgPSBHZW5TdGF0ZUNvbXBsZXRlZDtcbiAgICAgICAgICAvLyBEaXNwYXRjaCB0aGUgZXhjZXB0aW9uIGJ5IGxvb3BpbmcgYmFjayBhcm91bmQgdG8gdGhlXG4gICAgICAgICAgLy8gY29udGV4dC5kaXNwYXRjaEV4Y2VwdGlvbihjb250ZXh0LmFyZykgY2FsbCBhYm92ZS5cbiAgICAgICAgICBjb250ZXh0Lm1ldGhvZCA9IFwidGhyb3dcIjtcbiAgICAgICAgICBjb250ZXh0LmFyZyA9IHJlY29yZC5hcmc7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuICB9XG5cbiAgLy8gQ2FsbCBkZWxlZ2F0ZS5pdGVyYXRvcltjb250ZXh0Lm1ldGhvZF0oY29udGV4dC5hcmcpIGFuZCBoYW5kbGUgdGhlXG4gIC8vIHJlc3VsdCwgZWl0aGVyIGJ5IHJldHVybmluZyBhIHsgdmFsdWUsIGRvbmUgfSByZXN1bHQgZnJvbSB0aGVcbiAgLy8gZGVsZWdhdGUgaXRlcmF0b3IsIG9yIGJ5IG1vZGlmeWluZyBjb250ZXh0Lm1ldGhvZCBhbmQgY29udGV4dC5hcmcsXG4gIC8vIHNldHRpbmcgY29udGV4dC5kZWxlZ2F0ZSB0byBudWxsLCBhbmQgcmV0dXJuaW5nIHRoZSBDb250aW51ZVNlbnRpbmVsLlxuICBmdW5jdGlvbiBtYXliZUludm9rZURlbGVnYXRlKGRlbGVnYXRlLCBjb250ZXh0KSB7XG4gICAgdmFyIG1ldGhvZCA9IGRlbGVnYXRlLml0ZXJhdG9yW2NvbnRleHQubWV0aG9kXTtcbiAgICBpZiAobWV0aG9kID09PSB1bmRlZmluZWQpIHtcbiAgICAgIC8vIEEgLnRocm93IG9yIC5yZXR1cm4gd2hlbiB0aGUgZGVsZWdhdGUgaXRlcmF0b3IgaGFzIG5vIC50aHJvd1xuICAgICAgLy8gbWV0aG9kIGFsd2F5cyB0ZXJtaW5hdGVzIHRoZSB5aWVsZCogbG9vcC5cbiAgICAgIGNvbnRleHQuZGVsZWdhdGUgPSBudWxsO1xuXG4gICAgICBpZiAoY29udGV4dC5tZXRob2QgPT09IFwidGhyb3dcIikge1xuICAgICAgICBpZiAoZGVsZWdhdGUuaXRlcmF0b3IucmV0dXJuKSB7XG4gICAgICAgICAgLy8gSWYgdGhlIGRlbGVnYXRlIGl0ZXJhdG9yIGhhcyBhIHJldHVybiBtZXRob2QsIGdpdmUgaXQgYVxuICAgICAgICAgIC8vIGNoYW5jZSB0byBjbGVhbiB1cC5cbiAgICAgICAgICBjb250ZXh0Lm1ldGhvZCA9IFwicmV0dXJuXCI7XG4gICAgICAgICAgY29udGV4dC5hcmcgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgbWF5YmVJbnZva2VEZWxlZ2F0ZShkZWxlZ2F0ZSwgY29udGV4dCk7XG5cbiAgICAgICAgICBpZiAoY29udGV4dC5tZXRob2QgPT09IFwidGhyb3dcIikge1xuICAgICAgICAgICAgLy8gSWYgbWF5YmVJbnZva2VEZWxlZ2F0ZShjb250ZXh0KSBjaGFuZ2VkIGNvbnRleHQubWV0aG9kIGZyb21cbiAgICAgICAgICAgIC8vIFwicmV0dXJuXCIgdG8gXCJ0aHJvd1wiLCBsZXQgdGhhdCBvdmVycmlkZSB0aGUgVHlwZUVycm9yIGJlbG93LlxuICAgICAgICAgICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgY29udGV4dC5tZXRob2QgPSBcInRocm93XCI7XG4gICAgICAgIGNvbnRleHQuYXJnID0gbmV3IFR5cGVFcnJvcihcbiAgICAgICAgICBcIlRoZSBpdGVyYXRvciBkb2VzIG5vdCBwcm92aWRlIGEgJ3Rocm93JyBtZXRob2RcIik7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xuICAgIH1cblxuICAgIHZhciByZWNvcmQgPSB0cnlDYXRjaChtZXRob2QsIGRlbGVnYXRlLml0ZXJhdG9yLCBjb250ZXh0LmFyZyk7XG5cbiAgICBpZiAocmVjb3JkLnR5cGUgPT09IFwidGhyb3dcIikge1xuICAgICAgY29udGV4dC5tZXRob2QgPSBcInRocm93XCI7XG4gICAgICBjb250ZXh0LmFyZyA9IHJlY29yZC5hcmc7XG4gICAgICBjb250ZXh0LmRlbGVnYXRlID0gbnVsbDtcbiAgICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xuICAgIH1cblxuICAgIHZhciBpbmZvID0gcmVjb3JkLmFyZztcblxuICAgIGlmICghIGluZm8pIHtcbiAgICAgIGNvbnRleHQubWV0aG9kID0gXCJ0aHJvd1wiO1xuICAgICAgY29udGV4dC5hcmcgPSBuZXcgVHlwZUVycm9yKFwiaXRlcmF0b3IgcmVzdWx0IGlzIG5vdCBhbiBvYmplY3RcIik7XG4gICAgICBjb250ZXh0LmRlbGVnYXRlID0gbnVsbDtcbiAgICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xuICAgIH1cblxuICAgIGlmIChpbmZvLmRvbmUpIHtcbiAgICAgIC8vIEFzc2lnbiB0aGUgcmVzdWx0IG9mIHRoZSBmaW5pc2hlZCBkZWxlZ2F0ZSB0byB0aGUgdGVtcG9yYXJ5XG4gICAgICAvLyB2YXJpYWJsZSBzcGVjaWZpZWQgYnkgZGVsZWdhdGUucmVzdWx0TmFtZSAoc2VlIGRlbGVnYXRlWWllbGQpLlxuICAgICAgY29udGV4dFtkZWxlZ2F0ZS5yZXN1bHROYW1lXSA9IGluZm8udmFsdWU7XG5cbiAgICAgIC8vIFJlc3VtZSBleGVjdXRpb24gYXQgdGhlIGRlc2lyZWQgbG9jYXRpb24gKHNlZSBkZWxlZ2F0ZVlpZWxkKS5cbiAgICAgIGNvbnRleHQubmV4dCA9IGRlbGVnYXRlLm5leHRMb2M7XG5cbiAgICAgIC8vIElmIGNvbnRleHQubWV0aG9kIHdhcyBcInRocm93XCIgYnV0IHRoZSBkZWxlZ2F0ZSBoYW5kbGVkIHRoZVxuICAgICAgLy8gZXhjZXB0aW9uLCBsZXQgdGhlIG91dGVyIGdlbmVyYXRvciBwcm9jZWVkIG5vcm1hbGx5LiBJZlxuICAgICAgLy8gY29udGV4dC5tZXRob2Qgd2FzIFwibmV4dFwiLCBmb3JnZXQgY29udGV4dC5hcmcgc2luY2UgaXQgaGFzIGJlZW5cbiAgICAgIC8vIFwiY29uc3VtZWRcIiBieSB0aGUgZGVsZWdhdGUgaXRlcmF0b3IuIElmIGNvbnRleHQubWV0aG9kIHdhc1xuICAgICAgLy8gXCJyZXR1cm5cIiwgYWxsb3cgdGhlIG9yaWdpbmFsIC5yZXR1cm4gY2FsbCB0byBjb250aW51ZSBpbiB0aGVcbiAgICAgIC8vIG91dGVyIGdlbmVyYXRvci5cbiAgICAgIGlmIChjb250ZXh0Lm1ldGhvZCAhPT0gXCJyZXR1cm5cIikge1xuICAgICAgICBjb250ZXh0Lm1ldGhvZCA9IFwibmV4dFwiO1xuICAgICAgICBjb250ZXh0LmFyZyA9IHVuZGVmaW5lZDtcbiAgICAgIH1cblxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBSZS15aWVsZCB0aGUgcmVzdWx0IHJldHVybmVkIGJ5IHRoZSBkZWxlZ2F0ZSBtZXRob2QuXG4gICAgICByZXR1cm4gaW5mbztcbiAgICB9XG5cbiAgICAvLyBUaGUgZGVsZWdhdGUgaXRlcmF0b3IgaXMgZmluaXNoZWQsIHNvIGZvcmdldCBpdCBhbmQgY29udGludWUgd2l0aFxuICAgIC8vIHRoZSBvdXRlciBnZW5lcmF0b3IuXG4gICAgY29udGV4dC5kZWxlZ2F0ZSA9IG51bGw7XG4gICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XG4gIH1cblxuICAvLyBEZWZpbmUgR2VuZXJhdG9yLnByb3RvdHlwZS57bmV4dCx0aHJvdyxyZXR1cm59IGluIHRlcm1zIG9mIHRoZVxuICAvLyB1bmlmaWVkIC5faW52b2tlIGhlbHBlciBtZXRob2QuXG4gIGRlZmluZUl0ZXJhdG9yTWV0aG9kcyhHcCk7XG5cbiAgR3BbdG9TdHJpbmdUYWdTeW1ib2xdID0gXCJHZW5lcmF0b3JcIjtcblxuICAvLyBBIEdlbmVyYXRvciBzaG91bGQgYWx3YXlzIHJldHVybiBpdHNlbGYgYXMgdGhlIGl0ZXJhdG9yIG9iamVjdCB3aGVuIHRoZVxuICAvLyBAQGl0ZXJhdG9yIGZ1bmN0aW9uIGlzIGNhbGxlZCBvbiBpdC4gU29tZSBicm93c2VycycgaW1wbGVtZW50YXRpb25zIG9mIHRoZVxuICAvLyBpdGVyYXRvciBwcm90b3R5cGUgY2hhaW4gaW5jb3JyZWN0bHkgaW1wbGVtZW50IHRoaXMsIGNhdXNpbmcgdGhlIEdlbmVyYXRvclxuICAvLyBvYmplY3QgdG8gbm90IGJlIHJldHVybmVkIGZyb20gdGhpcyBjYWxsLiBUaGlzIGVuc3VyZXMgdGhhdCBkb2Vzbid0IGhhcHBlbi5cbiAgLy8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWdlbmVyYXRvci9pc3N1ZXMvMjc0IGZvciBtb3JlIGRldGFpbHMuXG4gIEdwW2l0ZXJhdG9yU3ltYm9sXSA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIEdwLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIFwiW29iamVjdCBHZW5lcmF0b3JdXCI7XG4gIH07XG5cbiAgZnVuY3Rpb24gcHVzaFRyeUVudHJ5KGxvY3MpIHtcbiAgICB2YXIgZW50cnkgPSB7IHRyeUxvYzogbG9jc1swXSB9O1xuXG4gICAgaWYgKDEgaW4gbG9jcykge1xuICAgICAgZW50cnkuY2F0Y2hMb2MgPSBsb2NzWzFdO1xuICAgIH1cblxuICAgIGlmICgyIGluIGxvY3MpIHtcbiAgICAgIGVudHJ5LmZpbmFsbHlMb2MgPSBsb2NzWzJdO1xuICAgICAgZW50cnkuYWZ0ZXJMb2MgPSBsb2NzWzNdO1xuICAgIH1cblxuICAgIHRoaXMudHJ5RW50cmllcy5wdXNoKGVudHJ5KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlc2V0VHJ5RW50cnkoZW50cnkpIHtcbiAgICB2YXIgcmVjb3JkID0gZW50cnkuY29tcGxldGlvbiB8fCB7fTtcbiAgICByZWNvcmQudHlwZSA9IFwibm9ybWFsXCI7XG4gICAgZGVsZXRlIHJlY29yZC5hcmc7XG4gICAgZW50cnkuY29tcGxldGlvbiA9IHJlY29yZDtcbiAgfVxuXG4gIGZ1bmN0aW9uIENvbnRleHQodHJ5TG9jc0xpc3QpIHtcbiAgICAvLyBUaGUgcm9vdCBlbnRyeSBvYmplY3QgKGVmZmVjdGl2ZWx5IGEgdHJ5IHN0YXRlbWVudCB3aXRob3V0IGEgY2F0Y2hcbiAgICAvLyBvciBhIGZpbmFsbHkgYmxvY2spIGdpdmVzIHVzIGEgcGxhY2UgdG8gc3RvcmUgdmFsdWVzIHRocm93biBmcm9tXG4gICAgLy8gbG9jYXRpb25zIHdoZXJlIHRoZXJlIGlzIG5vIGVuY2xvc2luZyB0cnkgc3RhdGVtZW50LlxuICAgIHRoaXMudHJ5RW50cmllcyA9IFt7IHRyeUxvYzogXCJyb290XCIgfV07XG4gICAgdHJ5TG9jc0xpc3QuZm9yRWFjaChwdXNoVHJ5RW50cnksIHRoaXMpO1xuICAgIHRoaXMucmVzZXQodHJ1ZSk7XG4gIH1cblxuICBydW50aW1lLmtleXMgPSBmdW5jdGlvbihvYmplY3QpIHtcbiAgICB2YXIga2V5cyA9IFtdO1xuICAgIGZvciAodmFyIGtleSBpbiBvYmplY3QpIHtcbiAgICAgIGtleXMucHVzaChrZXkpO1xuICAgIH1cbiAgICBrZXlzLnJldmVyc2UoKTtcblxuICAgIC8vIFJhdGhlciB0aGFuIHJldHVybmluZyBhbiBvYmplY3Qgd2l0aCBhIG5leHQgbWV0aG9kLCB3ZSBrZWVwXG4gICAgLy8gdGhpbmdzIHNpbXBsZSBhbmQgcmV0dXJuIHRoZSBuZXh0IGZ1bmN0aW9uIGl0c2VsZi5cbiAgICByZXR1cm4gZnVuY3Rpb24gbmV4dCgpIHtcbiAgICAgIHdoaWxlIChrZXlzLmxlbmd0aCkge1xuICAgICAgICB2YXIga2V5ID0ga2V5cy5wb3AoKTtcbiAgICAgICAgaWYgKGtleSBpbiBvYmplY3QpIHtcbiAgICAgICAgICBuZXh0LnZhbHVlID0ga2V5O1xuICAgICAgICAgIG5leHQuZG9uZSA9IGZhbHNlO1xuICAgICAgICAgIHJldHVybiBuZXh0O1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIFRvIGF2b2lkIGNyZWF0aW5nIGFuIGFkZGl0aW9uYWwgb2JqZWN0LCB3ZSBqdXN0IGhhbmcgdGhlIC52YWx1ZVxuICAgICAgLy8gYW5kIC5kb25lIHByb3BlcnRpZXMgb2ZmIHRoZSBuZXh0IGZ1bmN0aW9uIG9iamVjdCBpdHNlbGYuIFRoaXNcbiAgICAgIC8vIGFsc28gZW5zdXJlcyB0aGF0IHRoZSBtaW5pZmllciB3aWxsIG5vdCBhbm9ueW1pemUgdGhlIGZ1bmN0aW9uLlxuICAgICAgbmV4dC5kb25lID0gdHJ1ZTtcbiAgICAgIHJldHVybiBuZXh0O1xuICAgIH07XG4gIH07XG5cbiAgZnVuY3Rpb24gdmFsdWVzKGl0ZXJhYmxlKSB7XG4gICAgaWYgKGl0ZXJhYmxlKSB7XG4gICAgICB2YXIgaXRlcmF0b3JNZXRob2QgPSBpdGVyYWJsZVtpdGVyYXRvclN5bWJvbF07XG4gICAgICBpZiAoaXRlcmF0b3JNZXRob2QpIHtcbiAgICAgICAgcmV0dXJuIGl0ZXJhdG9yTWV0aG9kLmNhbGwoaXRlcmFibGUpO1xuICAgICAgfVxuXG4gICAgICBpZiAodHlwZW9mIGl0ZXJhYmxlLm5leHQgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICByZXR1cm4gaXRlcmFibGU7XG4gICAgICB9XG5cbiAgICAgIGlmICghaXNOYU4oaXRlcmFibGUubGVuZ3RoKSkge1xuICAgICAgICB2YXIgaSA9IC0xLCBuZXh0ID0gZnVuY3Rpb24gbmV4dCgpIHtcbiAgICAgICAgICB3aGlsZSAoKytpIDwgaXRlcmFibGUubGVuZ3RoKSB7XG4gICAgICAgICAgICBpZiAoaGFzT3duLmNhbGwoaXRlcmFibGUsIGkpKSB7XG4gICAgICAgICAgICAgIG5leHQudmFsdWUgPSBpdGVyYWJsZVtpXTtcbiAgICAgICAgICAgICAgbmV4dC5kb25lID0gZmFsc2U7XG4gICAgICAgICAgICAgIHJldHVybiBuZXh0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIG5leHQudmFsdWUgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgbmV4dC5kb25lID0gdHJ1ZTtcblxuICAgICAgICAgIHJldHVybiBuZXh0O1xuICAgICAgICB9O1xuXG4gICAgICAgIHJldHVybiBuZXh0Lm5leHQgPSBuZXh0O1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIFJldHVybiBhbiBpdGVyYXRvciB3aXRoIG5vIHZhbHVlcy5cbiAgICByZXR1cm4geyBuZXh0OiBkb25lUmVzdWx0IH07XG4gIH1cbiAgcnVudGltZS52YWx1ZXMgPSB2YWx1ZXM7XG5cbiAgZnVuY3Rpb24gZG9uZVJlc3VsdCgpIHtcbiAgICByZXR1cm4geyB2YWx1ZTogdW5kZWZpbmVkLCBkb25lOiB0cnVlIH07XG4gIH1cblxuICBDb250ZXh0LnByb3RvdHlwZSA9IHtcbiAgICBjb25zdHJ1Y3RvcjogQ29udGV4dCxcblxuICAgIHJlc2V0OiBmdW5jdGlvbihza2lwVGVtcFJlc2V0KSB7XG4gICAgICB0aGlzLnByZXYgPSAwO1xuICAgICAgdGhpcy5uZXh0ID0gMDtcbiAgICAgIC8vIFJlc2V0dGluZyBjb250ZXh0Ll9zZW50IGZvciBsZWdhY3kgc3VwcG9ydCBvZiBCYWJlbCdzXG4gICAgICAvLyBmdW5jdGlvbi5zZW50IGltcGxlbWVudGF0aW9uLlxuICAgICAgdGhpcy5zZW50ID0gdGhpcy5fc2VudCA9IHVuZGVmaW5lZDtcbiAgICAgIHRoaXMuZG9uZSA9IGZhbHNlO1xuICAgICAgdGhpcy5kZWxlZ2F0ZSA9IG51bGw7XG5cbiAgICAgIHRoaXMubWV0aG9kID0gXCJuZXh0XCI7XG4gICAgICB0aGlzLmFyZyA9IHVuZGVmaW5lZDtcblxuICAgICAgdGhpcy50cnlFbnRyaWVzLmZvckVhY2gocmVzZXRUcnlFbnRyeSk7XG5cbiAgICAgIGlmICghc2tpcFRlbXBSZXNldCkge1xuICAgICAgICBmb3IgKHZhciBuYW1lIGluIHRoaXMpIHtcbiAgICAgICAgICAvLyBOb3Qgc3VyZSBhYm91dCB0aGUgb3B0aW1hbCBvcmRlciBvZiB0aGVzZSBjb25kaXRpb25zOlxuICAgICAgICAgIGlmIChuYW1lLmNoYXJBdCgwKSA9PT0gXCJ0XCIgJiZcbiAgICAgICAgICAgICAgaGFzT3duLmNhbGwodGhpcywgbmFtZSkgJiZcbiAgICAgICAgICAgICAgIWlzTmFOKCtuYW1lLnNsaWNlKDEpKSkge1xuICAgICAgICAgICAgdGhpc1tuYW1lXSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuXG4gICAgc3RvcDogZnVuY3Rpb24oKSB7XG4gICAgICB0aGlzLmRvbmUgPSB0cnVlO1xuXG4gICAgICB2YXIgcm9vdEVudHJ5ID0gdGhpcy50cnlFbnRyaWVzWzBdO1xuICAgICAgdmFyIHJvb3RSZWNvcmQgPSByb290RW50cnkuY29tcGxldGlvbjtcbiAgICAgIGlmIChyb290UmVjb3JkLnR5cGUgPT09IFwidGhyb3dcIikge1xuICAgICAgICB0aHJvdyByb290UmVjb3JkLmFyZztcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXMucnZhbDtcbiAgICB9LFxuXG4gICAgZGlzcGF0Y2hFeGNlcHRpb246IGZ1bmN0aW9uKGV4Y2VwdGlvbikge1xuICAgICAgaWYgKHRoaXMuZG9uZSkge1xuICAgICAgICB0aHJvdyBleGNlcHRpb247XG4gICAgICB9XG5cbiAgICAgIHZhciBjb250ZXh0ID0gdGhpcztcbiAgICAgIGZ1bmN0aW9uIGhhbmRsZShsb2MsIGNhdWdodCkge1xuICAgICAgICByZWNvcmQudHlwZSA9IFwidGhyb3dcIjtcbiAgICAgICAgcmVjb3JkLmFyZyA9IGV4Y2VwdGlvbjtcbiAgICAgICAgY29udGV4dC5uZXh0ID0gbG9jO1xuXG4gICAgICAgIGlmIChjYXVnaHQpIHtcbiAgICAgICAgICAvLyBJZiB0aGUgZGlzcGF0Y2hlZCBleGNlcHRpb24gd2FzIGNhdWdodCBieSBhIGNhdGNoIGJsb2NrLFxuICAgICAgICAgIC8vIHRoZW4gbGV0IHRoYXQgY2F0Y2ggYmxvY2sgaGFuZGxlIHRoZSBleGNlcHRpb24gbm9ybWFsbHkuXG4gICAgICAgICAgY29udGV4dC5tZXRob2QgPSBcIm5leHRcIjtcbiAgICAgICAgICBjb250ZXh0LmFyZyA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiAhISBjYXVnaHQ7XG4gICAgICB9XG5cbiAgICAgIGZvciAodmFyIGkgPSB0aGlzLnRyeUVudHJpZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgICAgdmFyIGVudHJ5ID0gdGhpcy50cnlFbnRyaWVzW2ldO1xuICAgICAgICB2YXIgcmVjb3JkID0gZW50cnkuY29tcGxldGlvbjtcblxuICAgICAgICBpZiAoZW50cnkudHJ5TG9jID09PSBcInJvb3RcIikge1xuICAgICAgICAgIC8vIEV4Y2VwdGlvbiB0aHJvd24gb3V0c2lkZSBvZiBhbnkgdHJ5IGJsb2NrIHRoYXQgY291bGQgaGFuZGxlXG4gICAgICAgICAgLy8gaXQsIHNvIHNldCB0aGUgY29tcGxldGlvbiB2YWx1ZSBvZiB0aGUgZW50aXJlIGZ1bmN0aW9uIHRvXG4gICAgICAgICAgLy8gdGhyb3cgdGhlIGV4Y2VwdGlvbi5cbiAgICAgICAgICByZXR1cm4gaGFuZGxlKFwiZW5kXCIpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGVudHJ5LnRyeUxvYyA8PSB0aGlzLnByZXYpIHtcbiAgICAgICAgICB2YXIgaGFzQ2F0Y2ggPSBoYXNPd24uY2FsbChlbnRyeSwgXCJjYXRjaExvY1wiKTtcbiAgICAgICAgICB2YXIgaGFzRmluYWxseSA9IGhhc093bi5jYWxsKGVudHJ5LCBcImZpbmFsbHlMb2NcIik7XG5cbiAgICAgICAgICBpZiAoaGFzQ2F0Y2ggJiYgaGFzRmluYWxseSkge1xuICAgICAgICAgICAgaWYgKHRoaXMucHJldiA8IGVudHJ5LmNhdGNoTG9jKSB7XG4gICAgICAgICAgICAgIHJldHVybiBoYW5kbGUoZW50cnkuY2F0Y2hMb2MsIHRydWUpO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh0aGlzLnByZXYgPCBlbnRyeS5maW5hbGx5TG9jKSB7XG4gICAgICAgICAgICAgIHJldHVybiBoYW5kbGUoZW50cnkuZmluYWxseUxvYyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICB9IGVsc2UgaWYgKGhhc0NhdGNoKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5wcmV2IDwgZW50cnkuY2F0Y2hMb2MpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGhhbmRsZShlbnRyeS5jYXRjaExvYywgdHJ1ZSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICB9IGVsc2UgaWYgKGhhc0ZpbmFsbHkpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnByZXYgPCBlbnRyeS5maW5hbGx5TG9jKSB7XG4gICAgICAgICAgICAgIHJldHVybiBoYW5kbGUoZW50cnkuZmluYWxseUxvYyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwidHJ5IHN0YXRlbWVudCB3aXRob3V0IGNhdGNoIG9yIGZpbmFsbHlcIik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcblxuICAgIGFicnVwdDogZnVuY3Rpb24odHlwZSwgYXJnKSB7XG4gICAgICBmb3IgKHZhciBpID0gdGhpcy50cnlFbnRyaWVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICAgIHZhciBlbnRyeSA9IHRoaXMudHJ5RW50cmllc1tpXTtcbiAgICAgICAgaWYgKGVudHJ5LnRyeUxvYyA8PSB0aGlzLnByZXYgJiZcbiAgICAgICAgICAgIGhhc093bi5jYWxsKGVudHJ5LCBcImZpbmFsbHlMb2NcIikgJiZcbiAgICAgICAgICAgIHRoaXMucHJldiA8IGVudHJ5LmZpbmFsbHlMb2MpIHtcbiAgICAgICAgICB2YXIgZmluYWxseUVudHJ5ID0gZW50cnk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKGZpbmFsbHlFbnRyeSAmJlxuICAgICAgICAgICh0eXBlID09PSBcImJyZWFrXCIgfHxcbiAgICAgICAgICAgdHlwZSA9PT0gXCJjb250aW51ZVwiKSAmJlxuICAgICAgICAgIGZpbmFsbHlFbnRyeS50cnlMb2MgPD0gYXJnICYmXG4gICAgICAgICAgYXJnIDw9IGZpbmFsbHlFbnRyeS5maW5hbGx5TG9jKSB7XG4gICAgICAgIC8vIElnbm9yZSB0aGUgZmluYWxseSBlbnRyeSBpZiBjb250cm9sIGlzIG5vdCBqdW1waW5nIHRvIGFcbiAgICAgICAgLy8gbG9jYXRpb24gb3V0c2lkZSB0aGUgdHJ5L2NhdGNoIGJsb2NrLlxuICAgICAgICBmaW5hbGx5RW50cnkgPSBudWxsO1xuICAgICAgfVxuXG4gICAgICB2YXIgcmVjb3JkID0gZmluYWxseUVudHJ5ID8gZmluYWxseUVudHJ5LmNvbXBsZXRpb24gOiB7fTtcbiAgICAgIHJlY29yZC50eXBlID0gdHlwZTtcbiAgICAgIHJlY29yZC5hcmcgPSBhcmc7XG5cbiAgICAgIGlmIChmaW5hbGx5RW50cnkpIHtcbiAgICAgICAgdGhpcy5tZXRob2QgPSBcIm5leHRcIjtcbiAgICAgICAgdGhpcy5uZXh0ID0gZmluYWxseUVudHJ5LmZpbmFsbHlMb2M7XG4gICAgICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcy5jb21wbGV0ZShyZWNvcmQpO1xuICAgIH0sXG5cbiAgICBjb21wbGV0ZTogZnVuY3Rpb24ocmVjb3JkLCBhZnRlckxvYykge1xuICAgICAgaWYgKHJlY29yZC50eXBlID09PSBcInRocm93XCIpIHtcbiAgICAgICAgdGhyb3cgcmVjb3JkLmFyZztcbiAgICAgIH1cblxuICAgICAgaWYgKHJlY29yZC50eXBlID09PSBcImJyZWFrXCIgfHxcbiAgICAgICAgICByZWNvcmQudHlwZSA9PT0gXCJjb250aW51ZVwiKSB7XG4gICAgICAgIHRoaXMubmV4dCA9IHJlY29yZC5hcmc7XG4gICAgICB9IGVsc2UgaWYgKHJlY29yZC50eXBlID09PSBcInJldHVyblwiKSB7XG4gICAgICAgIHRoaXMucnZhbCA9IHRoaXMuYXJnID0gcmVjb3JkLmFyZztcbiAgICAgICAgdGhpcy5tZXRob2QgPSBcInJldHVyblwiO1xuICAgICAgICB0aGlzLm5leHQgPSBcImVuZFwiO1xuICAgICAgfSBlbHNlIGlmIChyZWNvcmQudHlwZSA9PT0gXCJub3JtYWxcIiAmJiBhZnRlckxvYykge1xuICAgICAgICB0aGlzLm5leHQgPSBhZnRlckxvYztcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XG4gICAgfSxcblxuICAgIGZpbmlzaDogZnVuY3Rpb24oZmluYWxseUxvYykge1xuICAgICAgZm9yICh2YXIgaSA9IHRoaXMudHJ5RW50cmllcy5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgICB2YXIgZW50cnkgPSB0aGlzLnRyeUVudHJpZXNbaV07XG4gICAgICAgIGlmIChlbnRyeS5maW5hbGx5TG9jID09PSBmaW5hbGx5TG9jKSB7XG4gICAgICAgICAgdGhpcy5jb21wbGV0ZShlbnRyeS5jb21wbGV0aW9uLCBlbnRyeS5hZnRlckxvYyk7XG4gICAgICAgICAgcmVzZXRUcnlFbnRyeShlbnRyeSk7XG4gICAgICAgICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuXG4gICAgXCJjYXRjaFwiOiBmdW5jdGlvbih0cnlMb2MpIHtcbiAgICAgIGZvciAodmFyIGkgPSB0aGlzLnRyeUVudHJpZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgICAgdmFyIGVudHJ5ID0gdGhpcy50cnlFbnRyaWVzW2ldO1xuICAgICAgICBpZiAoZW50cnkudHJ5TG9jID09PSB0cnlMb2MpIHtcbiAgICAgICAgICB2YXIgcmVjb3JkID0gZW50cnkuY29tcGxldGlvbjtcbiAgICAgICAgICBpZiAocmVjb3JkLnR5cGUgPT09IFwidGhyb3dcIikge1xuICAgICAgICAgICAgdmFyIHRocm93biA9IHJlY29yZC5hcmc7XG4gICAgICAgICAgICByZXNldFRyeUVudHJ5KGVudHJ5KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHRocm93bjtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBUaGUgY29udGV4dC5jYXRjaCBtZXRob2QgbXVzdCBvbmx5IGJlIGNhbGxlZCB3aXRoIGEgbG9jYXRpb25cbiAgICAgIC8vIGFyZ3VtZW50IHRoYXQgY29ycmVzcG9uZHMgdG8gYSBrbm93biBjYXRjaCBibG9jay5cbiAgICAgIHRocm93IG5ldyBFcnJvcihcImlsbGVnYWwgY2F0Y2ggYXR0ZW1wdFwiKTtcbiAgICB9LFxuXG4gICAgZGVsZWdhdGVZaWVsZDogZnVuY3Rpb24oaXRlcmFibGUsIHJlc3VsdE5hbWUsIG5leHRMb2MpIHtcbiAgICAgIHRoaXMuZGVsZWdhdGUgPSB7XG4gICAgICAgIGl0ZXJhdG9yOiB2YWx1ZXMoaXRlcmFibGUpLFxuICAgICAgICByZXN1bHROYW1lOiByZXN1bHROYW1lLFxuICAgICAgICBuZXh0TG9jOiBuZXh0TG9jXG4gICAgICB9O1xuXG4gICAgICBpZiAodGhpcy5tZXRob2QgPT09IFwibmV4dFwiKSB7XG4gICAgICAgIC8vIERlbGliZXJhdGVseSBmb3JnZXQgdGhlIGxhc3Qgc2VudCB2YWx1ZSBzbyB0aGF0IHdlIGRvbid0XG4gICAgICAgIC8vIGFjY2lkZW50YWxseSBwYXNzIGl0IG9uIHRvIHRoZSBkZWxlZ2F0ZS5cbiAgICAgICAgdGhpcy5hcmcgPSB1bmRlZmluZWQ7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xuICAgIH1cbiAgfTtcbn0pKFxuICAvLyBJbiBzbG9wcHkgbW9kZSwgdW5ib3VuZCBgdGhpc2AgcmVmZXJzIHRvIHRoZSBnbG9iYWwgb2JqZWN0LCBmYWxsYmFjayB0b1xuICAvLyBGdW5jdGlvbiBjb25zdHJ1Y3RvciBpZiB3ZSdyZSBpbiBnbG9iYWwgc3RyaWN0IG1vZGUuIFRoYXQgaXMgc2FkbHkgYSBmb3JtXG4gIC8vIG9mIGluZGlyZWN0IGV2YWwgd2hpY2ggdmlvbGF0ZXMgQ29udGVudCBTZWN1cml0eSBQb2xpY3kuXG4gIChmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcyB8fCAodHlwZW9mIHNlbGYgPT09IFwib2JqZWN0XCIgJiYgc2VsZik7XG4gIH0pKCkgfHwgRnVuY3Rpb24oXCJyZXR1cm4gdGhpc1wiKSgpXG4pO1xuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///3\n')},function(module,__webpack_exports__,__webpack_require__){"use strict";eval("__webpack_require__.r(__webpack_exports__);\n\n// CONCATENATED MODULE: ./app/lib/constants.js\nvar TEXT = 'text';\nvar MAPDATA = 'mapdata';\nvar MUSIC = 'music';\nvar MIDI = 'midi';\nvar MP3 = 'mp3';\nvar PNG = 'png';\nvar MUS = 'mus';\nvar GRAPHIC = 'graphic';\nvar FLAT = 'flat';\nvar MARKER = 'marker';\nvar ENDOOM = 'ENDOOM';\nvar TEXTUREx = ['TEXTURE1', 'TEXTURE2'];\nvar TEXTLUMPS = ['DEHACKED', 'MAPINFO', 'ZMAPINFO', 'EMAPINFO', 'DMXGUS', 'DMXGUSC', 'WADINFO', 'EMENUS', 'MUSINFO', 'SNDINFO', 'GLDEFS', 'KEYCONF', 'SCRIPTS', 'LANGUAGE', 'DECORATE', 'SBARINFO', 'MENUDEF'];\nvar DATA_LUMPS = ['PLAYPAL', 'COLORMAP', 'TEXTURE1', 'TEXTURE2', 'PNAMES', 'ENDOOM'];\nvar DEFAULT_EXTENSION = 'lmp';\nvar EXTENSIONS = {\n  text: 'txt',\n  mp3: 'mp3',\n  mus: 'mus',\n  midi: 'mid',\n  png: 'png'\n};\n/* Environment */\n\nvar NO_BRAND_ENV = 'development-no-brand';\n/* Workers */\n\nvar SERVICE_WORKER_CORE = 'service-worker-core.js';\nvar WEB_WORKER_MAX_RETRIES = 1;\n/* Web worker internal errors */\n\nvar INVALID_TEXT = 'INVALID_TEXT';\n/* Themes */\n\nvar DARK_THEME = 'dark';\nvar LIGHT_THEME = 'light';\n/* Input types */\n\nvar CHECKBOX = 'checkbox';\n/* File formats */\n\nvar SUPPORTED_FORMATS = ['.wad', '.zip', '.pk3', '.json'];\nvar VALID_FILE_FORMATS = ['', 'application/x-doom', 'application/zip', 'application/json'];\n/* WAD types */\n\nvar IWAD = 'IWAD';\nvar PWAD = 'PWAD';\nvar VALID_WAD_TYPES = [IWAD, PWAD];\n/* Lump types */\n\nvar MAP = 'maps';\nvar INTERMISSION = 'intermission';\nvar STATUS_BAR = 'status bar';\nvar MENU = 'menu';\nvar IMAGE_LUMPS = ['patches', 'flats', 'sprites', MENU, INTERMISSION, STATUS_BAR];\nvar UNCATEGORIZED = 'uncategorized';\n/* Lump names */\n\nvar THINGS = 'THINGS';\nvar TEXTMAP = 'TEXTMAP';\nvar ENDMAP = 'ENDMAP';\nvar MAP_LUMPS = [THINGS, 'LINEDEFS', 'SIDEDEFS', 'VERTEXES', 'SEGS', 'TEXTMAP', 'SSECTORS', 'NODES', 'SECTORS', 'REJECT', 'BLOCKMAP', // Hexen only\n'BEHAVIOR', // ZDoom only? (optional)\n'SCRIPTS', // Universal Doom Map Format only\n'ZNODES', 'DIALOGUE'];\nvar OPENGL_MAP_LUMPS = ['GL_VERT', 'GL_SEGS', 'GL_SSECT', 'GL_NODES', 'GL_PVS'];\nvar START_MARKERS = new RegExp(/^[0-9a-zA-Z]{0,2}_START$/);\nvar END_MARKERS = new RegExp(/^[0-9a-zA-Z]{0,2}_END$/);\nvar TEXTURE_LUMPS = new RegExp(/^TEXTURE[0-9a-zA-Z]$/);\nvar INTERMISSION_LUMPS = new RegExp(/^WI[0-9a-zA-Z_]{1,}$/); // Doom II\n\nvar INTERMISSION_MAP_NAME_LUMPS = new RegExp(/^CWILV[0-9a-zA-Z_]{1,}$/);\nvar STATUS_BAR_LUMPS = new RegExp(/^(ST|AMM|BRDR_)[0-9a-zA-Z_]{1,}$/);\n/* Unique lumps */\n\nvar ANSI_LUMPS = [// Doom or Chex Quest\n'ENDOOM', // Heretic\n'ENDTEXT', // Strife\n'ENDSTRF', // Boom\n'ENDBOOM' // lack of ANSI lump in IWAD = Hexen\n];\nvar MAPINFO = ['MAPINFO', 'ZMAPINFO'];\nvar PLAYPAL = 'PLAYPAL';\nvar COLORMAP = 'COLORMAP';\nvar PNAMES = 'PNAMES';\nvar SBARINFO = 'SBARINFO'; // Hexen only\n\nvar SNDINFO = 'SNDINFO';\nvar MENU_SCREENS = ['TITLEPIC', 'HELP', 'HELP1', 'HELP2', 'CREDIT'];\nvar INTER_SCREENS = ['INTERPIC', // Doom 1 registered\n'ENDPIC', 'VICTORY2', 'PFUB1', 'PFUB2', // Doom 2\n'BOSSBACK'];\nvar MUSIC_LUMPS = ['GENMIDI', 'DMXGUS', 'DMXGUSC'];\nvar DEMO_LUMPS = ['DEMO1', 'DEMO2', 'DEMO3', 'DEMO4'];\nvar END_LUMPS = new RegExp(/^END[0-9]{1,}$/);\n/* Lump original formats */\n\nvar ANSI = 'ANSI';\n/* Lump special values */\n\nvar LUMP_INDEX_ENTRY_SIZE = 16;\nvar LUMP_INDEX_ENTRY_OFFSET_TO_LUMP_SIZE = 4;\nvar LUMP_INDEX_ENTRY_OFFSET_TO_LUMP_NAME = 8;\nvar COLOR_COUNT_PER_PALETTE = 256;\nvar PALETTE_SIZE = 768;\nvar COLORMAP_SIZE = 256;\nvar BYTES_PER_COLOR = 3;\nvar GREEN_COLOR_OFFSET = 1;\nvar BLUE_COLOR_OFFSET = 2;\nvar FLAT_DIMENSIONS = 64;\nvar IMAGE_DATA_HEADER_SIZE = 8;\nvar IMAGE_DATA_BOUNDARY = 255;\nvar TRANSPARENT_PIXEL = -1;\nvar HEXEN_SOUND_ARCHIVE_PATH = '$ARCHIVEPATH';\nvar HEXEN_SOUND_REGISTERED = '$REGISTERED';\nvar HEXEN_MUSIC_KEYWORD = '$MAP';\n/* MUS -> MIDI conversion */\n\nvar MUS_HEADER = 'MUS';\nvar MUS_HEADER_SIGNATURE = ['M'.charCodeAt(0), 'U'.charCodeAt(0), 'S'.charCodeAt(0), 0x1a].join(' ');\nvar MIDI_HEADER = 'MThd';\nvar MIDI_HEADER_SIZE = 4;\nvar MIDI_HEADER_DATA = ['M'.charCodeAt(0), 'T'.charCodeAt(0), 'h'.charCodeAt(0), 'd'.charCodeAt(0), // Main header\n0x00, 0x00, 0x00, 0x06, // Header size\n0x00, 0x00, // MIDI type (0)\n0x00, 0x01, // Number of tracks\n0x00, 0x46, // Resolution\n'M'.charCodeAt(0), 'T'.charCodeAt(0), 'r'.charCodeAt(0), 'k'.charCodeAt(0), // Start of track\n0x00, 0x00, 0x00, 0x00 // Placeholder for track length\n];\nvar MUS_NUM_CHANNELS = 16;\nvar MUS_PERCUSSION_CHANNEL = 15;\nvar MIDI_PERCUSSION_CHANNEL = 9;\nvar MIDI_TRACKLENGTH_OFS = 18;\nvar MIDI_CONTROLLER_MAP = [0x00, 0x20, 0x01, 0x07, 0x0a, 0x0b, 0x5b, 0x5d, 0x40, 0x43, 0x78, 0x7b, 0x7e, 0x7f, 0x79]; // MUS event codes\n\nvar MUS_RELEASE_KEY = 0x00;\nvar MUS_PRESS_KEY = 0x10;\nvar MUS_PITCH_WHEEL = 0x20;\nvar MUS_SYSTEM_EVENT = 0x30;\nvar MUS_CHANGE_CONTROLLER = 0x40;\nvar MUS_SCORE_END = 0x60; // MIDI event codes\n\nvar MIDI_RELEASE_KEY = 0x80;\nvar MIDI_PRESS_KEY = 0x90;\nvar MIDI_CHANGE_CONTROLLER = 0xb0;\nvar MIDI_CHANGE_PATCH = 0xc0;\nvar MIDI_PITCH_WHEEL = 0xe0;\n/* MIDI player */\n\nvar MAX_I16 = Math.pow(2, 15);\nvar MIDI_AUDIO_BUFFER_SIZE = 8192; // signed 16-bit samples\n\nvar MIDI_AUDIO_S16LSB = 0x8010;\nvar MIDI_PATCH_URL = '/public/midi/pat/';\nvar MIDI_PLAYER_MESSAGE_PREFIX = 'Midi player:';\nvar MIDI_ERROR = 'MIDI_ERROR';\nvar MIDI_STATUS = 'MIDI_STATUS';\nvar MIDI_PRELOAD = 'MIDI_PRELOAD';\nvar MIDI_LOAD_FILE = 'MIDI_LOAD_FILE';\nvar MIDI_LOAD_PATCH = 'MIDI_LOAD_PATCH';\nvar MIDI_PLAY = 'MIDI_PLAY';\nvar MIDI_PAUSE = 'MIDI_PAUSE';\nvar MIDI_RESUME = 'MIDI_RESUME';\nvar MIDI_STOP = 'MIDI_STOP';\nvar MIDI_END = 'MIDI_END';\n/* DMX -> PCM conversion */\n\nvar DMX_HEADER_SIZE = 18;\nvar DMX_TAIL_PADDING = 2;\n/* PCM Player */\n\nvar DEFAULT_PCM_SAMPLE_RATE = 11025;\nvar DEFAULT_PCM_CONFIGURATION = {\n  encoding: '8bit',\n  channels: 1,\n  volume: 1,\n  logging: false\n};\nvar PCM_MAX_VALUES = {\n  '8bit': 255,\n  '16bit': 65535,\n  '32bit': 4294967295,\n  '32bitFloat': 1\n};\nvar PCM_TYPED_ARRAYS = {\n  '8bit': Uint8Array,\n  '16bit': Uint16Array,\n  '32bit': Uint32Array,\n  '32bitFloat': Float32Array\n};\nvar PCM_PLAYER_MESSAGE_PREFIX = 'PCM player:';\nvar PCM_STATUS = 'PCM_STATUS';\nvar PCM_ERROR = 'PCM_ERROR';\nvar PCM_PLAY = 'PCM_PLAY';\nvar PCM_PAUSE = 'PCM_PAUSE';\nvar PCM_STOP = 'PCM_STOP';\nvar PCM_END = 'PCM_END';\n/* Map data */\n\nvar MAP_PADDING = 64;\nvar MAP_DATA_SCHEMAS = {\n  THINGS: {\n    size: 10,\n    properties: [{\n      name: 'x',\n      format: 'Int16'\n    }, {\n      name: 'y',\n      format: 'Int16'\n    }, {\n      name: 'angle',\n      format: 'Int16'\n    }, {\n      name: 'type',\n      format: 'Int16'\n    }, {\n      name: 'flags',\n      format: 'Int16'\n    }]\n  },\n  VERTEXES: {\n    size: 4,\n    properties: [{\n      name: 'x',\n      format: 'Int16'\n    }, {\n      name: 'y',\n      format: 'Int16'\n    }]\n  },\n  LINEDEFS: {\n    size: 14,\n    properties: [{\n      name: 'vertex1'\n    }, {\n      name: 'vertex2'\n    }, {\n      name: 'flags'\n    }, {\n      name: 'action'\n    }, {\n      name: 'tag'\n    }, {\n      name: 'rightSidedef'\n    }, {\n      name: 'leftSidedef'\n    }]\n  },\n  SIDEDEFS: {\n    size: 30,\n    properties: [{\n      name: 'xOffset'\n    }, {\n      name: 'yOffset'\n    }, {\n      name: 'upper',\n      format: 'name'\n    }, {\n      name: 'lower',\n      format: 'name'\n    }, {\n      name: 'middle',\n      format: 'name'\n    }, {\n      name: 'sector'\n    }]\n  },\n  SECTORS: {\n    size: 26,\n    properties: [{\n      name: 'zFloor'\n    }, {\n      name: 'zCeil'\n    }, {\n      name: 'floorFlat',\n      format: 'name'\n    }, {\n      name: 'ceilFlat',\n      format: 'name'\n    }, {\n      name: 'light'\n    }, {\n      name: 'type'\n    }, {\n      name: 'tag'\n    }]\n  },\n  SEGS: {\n    size: 12,\n    properties: [{\n      name: 'vertex1'\n    }, {\n      name: 'vertex2'\n    }, {\n      name: 'angle'\n    }, {\n      name: 'linedef'\n    }, {\n      name: 'direction'\n    }, {\n      name: 'offset'\n    }]\n  },\n  SSECTORS: {\n    size: 4,\n    properties: [{\n      name: 'segCount'\n    }, {\n      name: 'first'\n    }]\n  },\n  NODES: {\n    size: 28,\n    properties: [{\n      name: 'partitionX'\n    }, {\n      name: 'partitionY'\n    }, {\n      name: 'changeX'\n    }, {\n      name: 'changeY'\n    }, // different form original\n    {\n      name: 'boundsRightTop'\n    }, {\n      name: 'boundsRightBottom'\n    }, {\n      name: 'boundsRightLeft'\n    }, {\n      name: 'boundsRightRight'\n    }, // different form original\n    {\n      name: 'boundsLeftTop'\n    }, {\n      name: 'boundsLeftBottom'\n    }, {\n      name: 'boundsLeftLeft'\n    }, {\n      name: 'boundsLeftRight'\n    }, {\n      name: 'childRight'\n    }, {\n      name: 'childLeft'\n    }]\n  }\n};\nvar HEXEN_MAP_DATA_SCHEMAS = {\n  THINGS: {\n    size: 20,\n    properties: [{\n      name: 'tid',\n      format: 'Int16'\n    }, {\n      name: 'x',\n      format: 'Int16'\n    }, {\n      name: 'y',\n      format: 'Int16'\n    }, {\n      name: 'z',\n      format: 'Int16'\n    }, {\n      name: 'angle',\n      format: 'Int16'\n    }, {\n      name: 'type',\n      format: 'Int16'\n    }, {\n      name: 'flags',\n      format: 'Int16'\n    }, {\n      name: 'special',\n      format: 'Int8',\n      littleEndian: false\n    }, // different from original\n    {\n      name: 'arg0',\n      format: 'Int8',\n      littleEndian: false\n    }, {\n      name: 'arg1',\n      format: 'Int8',\n      littleEndian: false\n    }, {\n      name: 'arg2',\n      format: 'Int8',\n      littleEndian: false\n    }, {\n      name: 'arg3',\n      format: 'Int8',\n      littleEndian: false\n    }, {\n      name: 'arg4',\n      format: 'Int8',\n      littleEndian: false\n    }]\n  },\n  LINEDEFS: {\n    size: 16,\n    properties: [{\n      name: 'vertex1'\n    }, {\n      name: 'vertex2'\n    }, {\n      name: 'flags'\n    }, {\n      name: 'action',\n      format: 'Uint8',\n      littleEndian: false\n    }, // different from original\n    {\n      name: 'arg0',\n      format: 'Int8',\n      littleEndian: false\n    }, {\n      name: 'arg1',\n      format: 'Int8',\n      littleEndian: false\n    }, {\n      name: 'arg2',\n      format: 'Int8',\n      littleEndian: false\n    }, {\n      name: 'arg3',\n      format: 'Int8',\n      littleEndian: false\n    }, {\n      name: 'arg4',\n      format: 'Int8',\n      littleEndian: false\n    }, {\n      name: 'rightSidedef'\n    }, {\n      name: 'leftSidedef'\n    }]\n  }\n};\nvar DEFAULT_MAP_PALETTE = {\n  background: {\n    blue: 0,\n    green: 0,\n    red: 0\n  },\n  solidWall: {\n    blue: 0,\n    green: 0,\n    red: 255\n  },\n  lowerWall: {\n    blue: 75,\n    green: 123,\n    red: 191\n  },\n  upperWall: {\n    blue: 0,\n    green: 255,\n    red: 255\n  },\n  sameHeight: {\n    blue: 131,\n    green: 131,\n    red: 131\n  }\n};\n/* ANSI conversion */\n\nvar ANSI_CODE_PAGE_437_TABLES = ['', '☺', '☻', '♥', '♦', '♣', '♠', '•', '◘', '○', '◙', '♂', '♀', '♪', '♫', '☼', '►', '◄', '↕', '‼', '¶', '§', '▬', '↨', '↑', '↓', '→', '←', '∟', '↔', '▲', '▼', ' ', '!', '\"', '#', '$', '%', '&', \"'\", '(', ')', '*', '+', ',', '-', '.', '/', '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', ':', ';', '<', '=', '>', '?', '@', 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z', '[', '\\\\', ']', '^', '_', '`', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z', '{', '|', '}', '~', '⌂', 'Ç', 'ü', 'é', 'â', 'ä', 'à', 'å', 'ç', 'ê', 'ë', 'è', 'ï', 'î', 'ì', 'Ä', 'Å', 'É', 'æ', 'Æ', 'ô', 'ö', 'ò', 'û', 'ù', 'ÿ', 'Ö', 'Ü', '¢', '£', '¥', '₧', 'ƒ', 'á', 'í', 'ó', 'ú', 'ñ', 'Ñ', 'ª', 'º', '¿', '⌐', '¬', '½', '¼', '¡', '«', '»', '░', '▒', '▓', '│', '┤', '╡', '╢', '╖', '╕', '╣', '║', '╗', '╝', '╜', '╛', '┐', '└', '┴', '┬', '├', '─', '┼', '╞', '╟', '╚', '╔', '╩', '╦', '╠', '═', '╬', '╧', '╨', '╤', '╥', '╙', '╘', '╒', '╓', '╫', '╪', '┘', '┌', '█', '▄', '▌', '▐', '▀', 'α', 'ß', 'Γ', 'π', 'Σ', 'σ', 'µ', 'τ', 'Φ', 'Θ', 'Ω', 'δ', '∞', 'φ', 'ε', '∩', '≡', '±', '≥', '≤', '⌠', '⌡', '÷', '≈', '°', '∙', '·', '√', 'ⁿ', '²', '■', ' '];\nvar ANSI_BACKGROUND_COLOR_CODES = ['black', 'blue', 'green', 'cyan', 'red', 'magenta', 'brown', 'light-gray'];\nvar ANSI_FOREGROUND_COLOR_CODES = ['black', 'blue', 'green', 'cyan', 'red', 'magenta', 'brown', 'light-gray', 'dark-gray', 'light-blue', 'light-green', 'light-cyan', 'light-red', 'light-magenta', 'yellow', 'white'];\n// EXTERNAL MODULE: ./node_modules/@babel/runtime/regenerator/index.js\nvar regenerator = __webpack_require__(0);\nvar regenerator_default = /*#__PURE__*/__webpack_require__.n(regenerator);\n\n// EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/asyncToGenerator.js\nvar asyncToGenerator = __webpack_require__(1);\nvar asyncToGenerator_default = /*#__PURE__*/__webpack_require__.n(asyncToGenerator);\n\n// CONCATENATED MODULE: ./app/lib/cacheManager.js\n\n\nvar setCacheItemAsBlob = function setCacheItemAsBlob(_ref) {\n  var cacheId = _ref.cacheId,\n      requestURL = _ref.requestURL,\n      responseData = _ref.responseData;\n  var response = new Response(responseData);\n  caches.open(cacheId).then(function (cache) {\n    return cache.put(requestURL, response);\n  });\n};\nvar getCacheItemAsArrayBuffer =\n/*#__PURE__*/\nfunction () {\n  var _ref3 = asyncToGenerator_default()(\n  /*#__PURE__*/\n  regenerator_default.a.mark(function _callee(_ref2) {\n    var cacheId, requestURL, cache, response;\n    return regenerator_default.a.wrap(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            cacheId = _ref2.cacheId, requestURL = _ref2.requestURL;\n            _context.prev = 1;\n            _context.next = 4;\n            return caches.open(cacheId);\n\n          case 4:\n            cache = _context.sent;\n            _context.next = 7;\n            return cache.match(requestURL);\n\n          case 7:\n            response = _context.sent;\n\n            if (response) {\n              _context.next = 10;\n              break;\n            }\n\n            return _context.abrupt(\"return\", null);\n\n          case 10:\n            _context.next = 12;\n            return response.arrayBuffer();\n\n          case 12:\n            return _context.abrupt(\"return\", _context.sent);\n\n          case 15:\n            _context.prev = 15;\n            _context.t0 = _context[\"catch\"](1);\n            console.error(\"An error occurred while retrieving cache of '\".concat(requestURL, \"'.\"), {\n              error: _context.t0\n            });\n            return _context.abrupt(\"return\", null);\n\n          case 19:\n          case \"end\":\n            return _context.stop();\n        }\n      }\n    }, _callee, null, [[1, 15]]);\n  }));\n\n  return function getCacheItemAsArrayBuffer(_x) {\n    return _ref3.apply(this, arguments);\n  };\n}();\nvar getCacheItemAsBlob =\n/*#__PURE__*/\nfunction () {\n  var _ref5 = asyncToGenerator_default()(\n  /*#__PURE__*/\n  regenerator_default.a.mark(function _callee2(_ref4) {\n    var cacheId, requestURL, cache, response;\n    return regenerator_default.a.wrap(function _callee2$(_context2) {\n      while (1) {\n        switch (_context2.prev = _context2.next) {\n          case 0:\n            cacheId = _ref4.cacheId, requestURL = _ref4.requestURL;\n            _context2.prev = 1;\n            _context2.next = 4;\n            return caches.open(cacheId);\n\n          case 4:\n            cache = _context2.sent;\n            _context2.next = 7;\n            return cache.match(requestURL);\n\n          case 7:\n            response = _context2.sent;\n\n            if (response) {\n              _context2.next = 10;\n              break;\n            }\n\n            return _context2.abrupt(\"return\", null);\n\n          case 10:\n            _context2.next = 12;\n            return response.blob();\n\n          case 12:\n            return _context2.abrupt(\"return\", _context2.sent);\n\n          case 15:\n            _context2.prev = 15;\n            _context2.t0 = _context2[\"catch\"](1);\n            console.error(\"An error occurred while retrieving cache of '\".concat(requestURL, \"'.\"), {\n              error: _context2.t0\n            });\n            return _context2.abrupt(\"return\", null);\n\n          case 19:\n          case \"end\":\n            return _context2.stop();\n        }\n      }\n    }, _callee2, null, [[1, 15]]);\n  }));\n\n  return function getCacheItemAsBlob(_x2) {\n    return _ref5.apply(this, arguments);\n  };\n}();\nvar getCacheItemAsJson =\n/*#__PURE__*/\nfunction () {\n  var _ref7 = asyncToGenerator_default()(\n  /*#__PURE__*/\n  regenerator_default.a.mark(function _callee3(_ref6) {\n    var cacheId, requestURL, cache, response;\n    return regenerator_default.a.wrap(function _callee3$(_context3) {\n      while (1) {\n        switch (_context3.prev = _context3.next) {\n          case 0:\n            cacheId = _ref6.cacheId, requestURL = _ref6.requestURL;\n            _context3.prev = 1;\n            _context3.next = 4;\n            return caches.open(cacheId);\n\n          case 4:\n            cache = _context3.sent;\n            _context3.next = 7;\n            return cache.match(requestURL);\n\n          case 7:\n            response = _context3.sent;\n\n            if (response) {\n              _context3.next = 10;\n              break;\n            }\n\n            return _context3.abrupt(\"return\", null);\n\n          case 10:\n            _context3.next = 12;\n            return response.json();\n\n          case 12:\n            return _context3.abrupt(\"return\", _context3.sent);\n\n          case 15:\n            _context3.prev = 15;\n            _context3.t0 = _context3[\"catch\"](1);\n            console.error(\"An error occurred while retrieving cache of '\".concat(requestURL, \"'.\"), {\n              error: _context3.t0\n            });\n            return _context3.abrupt(\"return\", null);\n\n          case 19:\n          case \"end\":\n            return _context3.stop();\n        }\n      }\n    }, _callee3, null, [[1, 15]]);\n  }));\n\n  return function getCacheItemAsJson(_x3) {\n    return _ref7.apply(this, arguments);\n  };\n}();\nvar getCacheItemAsText =\n/*#__PURE__*/\nfunction () {\n  var _ref9 = asyncToGenerator_default()(\n  /*#__PURE__*/\n  regenerator_default.a.mark(function _callee4(_ref8) {\n    var cacheId, requestURL, cache, response;\n    return regenerator_default.a.wrap(function _callee4$(_context4) {\n      while (1) {\n        switch (_context4.prev = _context4.next) {\n          case 0:\n            cacheId = _ref8.cacheId, requestURL = _ref8.requestURL;\n            _context4.prev = 1;\n            _context4.next = 4;\n            return caches.open(cacheId);\n\n          case 4:\n            cache = _context4.sent;\n            _context4.next = 7;\n            return cache.match(requestURL);\n\n          case 7:\n            response = _context4.sent;\n\n            if (response) {\n              _context4.next = 10;\n              break;\n            }\n\n            return _context4.abrupt(\"return\", null);\n\n          case 10:\n            _context4.next = 12;\n            return response.text();\n\n          case 12:\n            return _context4.abrupt(\"return\", _context4.sent);\n\n          case 15:\n            _context4.prev = 15;\n            _context4.t0 = _context4[\"catch\"](1);\n            console.error(\"An error occurred while retrieving cache of '\".concat(requestURL, \"'.\"), {\n              error: _context4.t0\n            });\n            return _context4.abrupt(\"return\", null);\n\n          case 19:\n          case \"end\":\n            return _context4.stop();\n        }\n      }\n    }, _callee4, null, [[1, 15]]);\n  }));\n\n  return function getCacheItemAsText(_x4) {\n    return _ref9.apply(this, arguments);\n  };\n}();\nvar deleteCache =\n/*#__PURE__*/\nfunction () {\n  var _ref11 = asyncToGenerator_default()(\n  /*#__PURE__*/\n  regenerator_default.a.mark(function _callee5(_ref10) {\n    var cacheId;\n    return regenerator_default.a.wrap(function _callee5$(_context5) {\n      while (1) {\n        switch (_context5.prev = _context5.next) {\n          case 0:\n            cacheId = _ref10.cacheId;\n            _context5.prev = 1;\n            _context5.next = 4;\n            return caches.delete(cacheId);\n\n          case 4:\n            return _context5.abrupt(\"return\", true);\n\n          case 7:\n            _context5.prev = 7;\n            _context5.t0 = _context5[\"catch\"](1);\n            console.error(\"An error occurred while deleting cache of '\".concat(cacheId, \"'.\"), {\n              error: _context5.t0\n            });\n            return _context5.abrupt(\"return\", false);\n\n          case 11:\n          case \"end\":\n            return _context5.stop();\n        }\n      }\n    }, _callee5, null, [[1, 7]]);\n  }));\n\n  return function deleteCache(_x5) {\n    return _ref11.apply(this, arguments);\n  };\n}();\nvar deleteAllCache =\n/*#__PURE__*/\nfunction () {\n  var _ref12 = asyncToGenerator_default()(\n  /*#__PURE__*/\n  regenerator_default.a.mark(function _callee7() {\n    var cacheKeys;\n    return regenerator_default.a.wrap(function _callee7$(_context7) {\n      while (1) {\n        switch (_context7.prev = _context7.next) {\n          case 0:\n            _context7.prev = 0;\n            _context7.next = 3;\n            return caches.keys();\n\n          case 3:\n            cacheKeys = _context7.sent;\n            _context7.next = 6;\n            return cacheKeys.map(\n            /*#__PURE__*/\n            function () {\n              var _ref13 = asyncToGenerator_default()(\n              /*#__PURE__*/\n              regenerator_default.a.mark(function _callee6(key) {\n                return regenerator_default.a.wrap(function _callee6$(_context6) {\n                  while (1) {\n                    switch (_context6.prev = _context6.next) {\n                      case 0:\n                        _context6.next = 2;\n                        return caches.delete(key);\n\n                      case 2:\n                      case \"end\":\n                        return _context6.stop();\n                    }\n                  }\n                }, _callee6);\n              }));\n\n              return function (_x6) {\n                return _ref13.apply(this, arguments);\n              };\n            }());\n\n          case 6:\n            return _context7.abrupt(\"return\", true);\n\n          case 9:\n            _context7.prev = 9;\n            _context7.t0 = _context7[\"catch\"](0);\n            console.error('An error occurred while deleting the cache.', {\n              error: _context7.t0\n            });\n            return _context7.abrupt(\"return\", false);\n\n          case 13:\n          case \"end\":\n            return _context7.stop();\n        }\n      }\n    }, _callee7, null, [[0, 9]]);\n  }));\n\n  return function deleteAllCache() {\n    return _ref12.apply(this, arguments);\n  };\n}();\n// CONCATENATED MODULE: ./app/webWorkers/midiConverter.js\n\n\n\n\nfunction readMusHeader(dataView) {\n    const id = [];\n\n    for (let i = 0; i < 4; i++) {\n        id.push(dataView.getUint8(i));\n    }\n\n    const musHeader = {\n        // used to check that this is a valid MUS file\n        id: id.join(' '),\n        scoreLength: dataView.getUint16(4, true),\n        // only this value is truly helpful to parse the MUS\n        scoreStart: dataView.getUint16(6, true),\n        primaryChannels: dataView.getUint16(8, true),\n        secondaryChannels: dataView.getUint16(10, true),\n        instrumentCount: dataView.getUint16(12, true)\n    };\n\n    return musHeader;\n}\n\nfunction isValidMusHeader(id) {\n    return MUS_HEADER_SIGNATURE === id;\n}\n\n// TODO: Send the error string in postMessage\n\nonmessage = async message => {\n    try {\n        const { wadId, lump } = message.data;\n\n        const { name, type, data, originalFormat } = lump;\n\n        const requestURL = `/midis/${wadId}/${name}`;\n\n        if (originalFormat === 'MIDI') {\n            setCacheItemAsBlob({\n                cacheId: wadId,\n                requestURL,\n                responseData: data\n            });\n\n            postMessage({\n                wadId,\n                lumpId: name,\n                lumpType: type,\n                output: requestURL\n            });\n\n            return;\n        }\n\n        const cachedItem = await getCacheItemAsArrayBuffer({\n            cacheId: wadId,\n            requestURL\n        });\n\n        if (cachedItem) {\n            postMessage({\n                wadId,\n                lumpId: name,\n                lumpType: type,\n                output: requestURL\n            });\n\n            return;\n        }\n\n        // console.log(`Converting '${type}/${name}' from MUS to MIDI (WAD: '${wadId}') ...`);\n\n        let musDataView;\n        let musDataPosition;\n\n        // Cached channel velocities\n        const channelvelocities = [\n            127,\n            127,\n            127,\n            127,\n            127,\n            127,\n            127,\n            127,\n            127,\n            127,\n            127,\n            127,\n            127,\n            127,\n            127,\n            127\n        ];\n\n        // Timestamps between sequences of MUS events\n        let queuedtime = 0;\n\n        // Counter for the length of the track\n        let tracksize;\n\n        const channelMap = [];\n\n        // Main DataView for writing to. This is used by writeData();\n        let outputDataView;\n\n        // Wrapper function to work like slade's memchunk.write()\n        // I'm so lazy\n        let position = 0;\n        let dataToWrite = [];\n        function writeData(bytes) {\n            dataToWrite = dataToWrite.concat(bytes);\n        }\n\n        function confirmWrite() {\n            const newBuffer = new ArrayBuffer(dataToWrite.length);\n            outputDataView = new DataView(newBuffer);\n            // Then write the data\n            for (let i = 0; i < dataToWrite.length; i++) {\n                outputDataView.setUint8(position, dataToWrite[i]);\n                position += 1;\n            }\n        }\n\n        // Write timestamp to a MIDI file.\n        function writeTime(time) {\n            let buffer = time & 0x7f;\n            let writeval;\n\n            while ((time >>= 7) != 0) {\n                buffer <<= 8;\n                buffer |= (time & 0x7f) | 0x80;\n            }\n\n            for (;;) {\n                writeval = buffer & 0xff;\n\n                writeData([writeval]);\n\n                tracksize += 1;\n\n                if ((buffer & 0x80) != 0) {\n                    buffer >>= 8;\n                } else {\n                    queuedtime = 0;\n                    return;\n                }\n            }\n        }\n\n        // Write the end of track marker\n        function writeEndTrack() {\n            const endtrack = [0xff, 0x2f, 0x00];\n\n            writeTime(queuedtime);\n\n            writeData(endtrack);\n\n            tracksize += 3;\n        }\n\n        // Write a key press event\n        function writePressKey(channel, key, velocity) {\n            // Write queued time\n            writeTime(queuedtime);\n\n            // Write pressed key and channel\n            let working = MIDI_PRESS_KEY | channel;\n            writeData([working]);\n\n            // Write key\n            working = key & 0x7f;\n            writeData([working]);\n\n            // Wite velocity\n            working = velocity & 0x7f;\n            writeData([working]);\n\n            tracksize += 3;\n        }\n\n        // Write a key release event\n        function writeReleaseKey(channel, key) {\n            // Write queued time\n            writeTime(queuedtime);\n\n            // Write released key\n            let working = MIDI_RELEASE_KEY | channel;\n            writeData([working]);\n\n            // Write key\n            working = key & 0x7f;\n            writeData([working]);\n\n            // Dummy\n            working = 0;\n            writeData([working]);\n\n            tracksize += 3;\n        }\n\n        // Write a pitch wheel/bend event\n        function writePitchWheel(channel, wheel) {\n            // Write queued time\n            writeTime(queuedtime);\n\n            let working = MIDI_PITCH_WHEEL | channel;\n            writeData([working]);\n\n            working = wheel & 0x7f;\n            writeData([working]);\n\n            working = (wheel >> 7) & 0x7f;\n            writeData([working]);\n\n            tracksize += 3;\n        }\n\n        // Write a patch change event\n        function writeChangePatch(channel, patch) {\n            // Write queued time\n            writeTime(queuedtime);\n\n            let working = MIDI_CHANGE_PATCH | channel;\n            writeData([working]);\n\n            working = patch & 0x7f;\n            writeData([working]);\n\n            tracksize += 2;\n        }\n\n        // Write a valued controller change event\n        function writeChangeControllerValued(channel, control, value) {\n            // Write queued time\n            writeTime(queuedtime);\n\n            let working = MIDI_CHANGE_CONTROLLER | channel;\n            writeData([working]);\n\n            working = control & 0x7f;\n            writeData([working]);\n\n            // Quirk in vanilla DOOM? MUS controller values should be 7-bit, not 8-bit.\n            working = value & 0x80 ? 0x7f : value;\n            writeData([working]);\n\n            tracksize += 3;\n        }\n\n        // Write a valueless controller change event\n        function writeChangeControllerValueless(channel, control) {\n            writeChangeControllerValued(channel, control, 0);\n        }\n\n        // Allocate a free MIDI channel.\n        function allocateMIDIChannel() {\n            let result;\n            let max;\n            let i;\n\n            // Find the current highest-allocated channel.\n\n            max = -1;\n\n            for (i = 0; i < MUS_NUM_CHANNELS; ++i) {\n                if (channelMap[i] > max) {\n                    max = channelMap[i];\n                }\n            }\n\n            // max is now equal to the highest-allocated MIDI channel.  We can\n            // now allocate the next available channel.  This also works if\n            // no channels are currently allocated (max=-1)\n\n            result = max + 1;\n\n            // Don't allocate the MIDI percussion channel!\n\n            if (result === MIDI_PERCUSSION_CHANNEL) {\n                ++result;\n            }\n\n            return result;\n        }\n\n        // Given a MUS channel number, get the MIDI channel number to use in the outputted file.\n        function getMIDIChannel(musChannel) {\n            // Find the MIDI channel to use for this MUS channel.\n            // MUS channel 15 is the percusssion channel.\n\n            if (musChannel === MUS_PERCUSSION_CHANNEL) {\n                return MIDI_PERCUSSION_CHANNEL;\n            }\n\n            // If a MIDI channel hasn't been allocated for this MUS channel\n            // yet, allocate the next free MIDI channel.\n\n            if (channelMap[musChannel] === -1) {\n                channelMap[musChannel] = allocateMIDIChannel();\n            }\n\n            return channelMap[musChannel];\n        }\n\n        function convertMusToMidi(musinput) {\n            // master dataview for input mus\n            musDataView = musinput;\n            musDataPosition = 0;\n\n            function getMusByte8() {\n                const output = musDataView.getUint8(musDataPosition);\n                musDataPosition += 1;\n                // console.log(output);\n                return output;\n            }\n\n            // master data for output midi\n            const outputArrayBuffer = new ArrayBuffer(0);\n            outputDataView = new DataView(outputArrayBuffer);\n\n            // Descriptor for the current MUS event\n            let eventdescriptor;\n            let channel; // Channel number\n            let musEvent;\n\n            // Bunch of vars read from MUS lump\n            let key;\n            let controllernumber;\n            let controllervalue;\n\n            // Flag for when the score end marker is hit.\n            let hitScoreEnd = false;\n\n            // Temp working byte\n            let working;\n            // Used in building up time delays\n            let timedelay;\n\n            // Initialise channel map to mark all channels as unused.\n            for (channel = 0; channel < MUS_NUM_CHANNELS; ++channel) {\n                channelMap[channel] = -1;\n            }\n\n            const musHeader = readMusHeader(musDataView);\n\n            if (!isValidMusHeader(musHeader.id)) {\n                console.error(\n                    `Invalid MUS header: '${\n                        musHeader.id\n                    }'. Expected: '${MUS_HEADER_SIGNATURE}'`\n                );\n                return false;\n            }\n\n            // Seek to where the data is held\n            musDataPosition = musHeader.scoreStart;\n            // So, we can assume the MUS file is faintly legit. Let's start writing MIDI data...\n\n            writeData(MIDI_HEADER_DATA);\n            tracksize = 0;\n\n            // Now, process the MUS file:\n            while (!hitScoreEnd) {\n                // Handle a block of events:\n\n                while (!hitScoreEnd) {\n                    // Fetch channel number and event code:\n                    eventdescriptor = getMusByte8();\n\n                    channel = getMIDIChannel(eventdescriptor & 0x0f);\n                    musEvent = eventdescriptor & 0x70;\n                    switch (musEvent) {\n                        case MUS_RELEASE_KEY:\n                            // console.log('MUS_RELEASE_KEY');\n                            key = getMusByte8();\n\n                            writeReleaseKey(channel, key);\n\n                            break;\n\n                        case MUS_PRESS_KEY:\n                            key = getMusByte8();\n\n                            if (key & 0x80) {\n                                channelvelocities[channel] = getMusByte8();\n\n                                channelvelocities[channel] &= 0x7f;\n\n                                // console.log('MUS_PRESS_KEY: '+key+ ' ' + channelvelocities[channel]);\n                            } else {\n                                // console.log('MUS_PRESS_KEY: '+key);\n                            }\n\n                            writePressKey(\n                                channel,\n                                key,\n                                channelvelocities[channel]\n                            );\n\n                            break;\n\n                        case MUS_PITCH_WHEEL:\n                            // console.log('MUS_PITCH_WHEEL');\n                            key = getMusByte8();\n\n                            writePitchWheel(channel, key * 64);\n\n                            break;\n\n                        case MUS_SYSTEM_EVENT:\n                            // console.log('MUS_SYSTEM_EVENT');\n                            controllernumber = getMusByte8();\n\n                            if (\n                                controllernumber < 10 ||\n                                controllernumber > 14\n                            ) {\n                                console.error(\n                                    `Controller number inaccurate 10-14: ${controllernumber}`\n                                );\n                                return false;\n                            }\n\n                            writeChangeControllerValueless(\n                                channel,\n                                MIDI_CONTROLLER_MAP[controllernumber]\n                            );\n\n                            break;\n\n                        case MUS_CHANGE_CONTROLLER:\n                            controllernumber = getMusByte8();\n                            controllervalue = getMusByte8();\n                            // console.log('MUS_CHANGE_CONTROLLER: ' +controllernumber+' '+controllervalue);\n                            if (controllernumber == 0) {\n                                writeChangePatch(channel, controllervalue);\n                            } else {\n                                if (\n                                    controllernumber < 1 ||\n                                    controllernumber > 9\n                                ) {\n                                    console.error(\n                                        `Controller number inaccurate: ${controllernumber}`\n                                    );\n                                    return false;\n                                }\n\n                                writeChangeControllerValued(\n                                    channel,\n                                    MIDI_CONTROLLER_MAP[controllernumber],\n                                    controllervalue\n                                );\n                            }\n\n                            break;\n\n                        case MUS_SCORE_END:\n                            // console.log('musScoreEnd');\n                            hitScoreEnd = true;\n                            break;\n\n                        default:\n                            // console.log('eventdescriptor default: '+eventdescriptor + ' ' + (eventdescriptor & 0x80));\n                            return false;\n                    }\n                    if ((eventdescriptor & 0x80) != 0) {\n                        // console.log('delay count');\n                        break;\n                    }\n                }\n                // Now we need to read the time code:\n                if (!hitScoreEnd) {\n                    // console.log('read time code');\n                    timedelay = 0;\n                    // delayCounter = 0;\n                    for (;;) {\n                        working = getMusByte8();\n                        // delayCounter += 1;\n                        timedelay = timedelay * 128 + (working & 0x7f);\n                        if ((working & 0x80) == 0) {\n                            break;\n                        }\n                    }\n                    // console.log('delay count: '+delayCounter + ' time delay: ' + timedelay)\n                    queuedtime += timedelay;\n                }\n            }\n            // console.log(`Converted '${lumpId}' from MUS to MIDI (WAD: '${wadId}').`);\n            // End of track\n            writeEndTrack();\n\n            confirmWrite();\n\n            // Write the track size into the stream\n            outputDataView.setUint8(\n                MIDI_TRACKLENGTH_OFS + 0,\n                (tracksize >> 24) & 0xff\n            );\n            outputDataView.setUint8(\n                MIDI_TRACKLENGTH_OFS + 1,\n                (tracksize >> 16) & 0xff\n            );\n            outputDataView.setUint8(\n                MIDI_TRACKLENGTH_OFS + 2,\n                (tracksize >> 8) & 0xff\n            );\n            outputDataView.setUint8(MIDI_TRACKLENGTH_OFS + 3, tracksize & 0xff);\n\n            return outputDataView.buffer;\n        }\n\n        const midi = convertMusToMidi(data);\n        if (!midi) {\n            console.error(\n                `Failed to convert '${type}/${name}' from MUS to MIDI (WAD: '${wadId}').`,\n                { musDataPosition }\n            );\n        }\n\n        setCacheItemAsBlob({ cacheId: wadId, requestURL, responseData: midi });\n\n        postMessage({\n            wadId,\n            lumpId: name,\n            lumpType: type,\n            output: requestURL\n        });\n    } catch (error) {\n        console.error('Something bad happened in midiConverter.', { error });\n    }\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNC5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL2FwcC9saWIvY29uc3RhbnRzLmpzP2I2NGQiLCJ3ZWJwYWNrOi8vLy4vYXBwL2xpYi9jYWNoZU1hbmFnZXIuanM/YTM5MiIsIndlYnBhY2s6Ly8vLi9hcHAvd2ViV29ya2Vycy9taWRpQ29udmVydGVyLmpzPzY3M2QiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IGNvbnN0IFRFWFQgPSAndGV4dCc7XG5leHBvcnQgY29uc3QgTUFQREFUQSA9ICdtYXBkYXRhJztcbmV4cG9ydCBjb25zdCBNVVNJQyA9ICdtdXNpYyc7XG5leHBvcnQgY29uc3QgTUlESSA9ICdtaWRpJztcbmV4cG9ydCBjb25zdCBNUDMgPSAnbXAzJztcbmV4cG9ydCBjb25zdCBQTkcgPSAncG5nJztcbmV4cG9ydCBjb25zdCBNVVMgPSAnbXVzJztcbmV4cG9ydCBjb25zdCBHUkFQSElDID0gJ2dyYXBoaWMnO1xuZXhwb3J0IGNvbnN0IEZMQVQgPSAnZmxhdCc7XG5leHBvcnQgY29uc3QgTUFSS0VSID0gJ21hcmtlcic7XG5leHBvcnQgY29uc3QgRU5ET09NID0gJ0VORE9PTSc7XG5leHBvcnQgY29uc3QgVEVYVFVSRXggPSBbJ1RFWFRVUkUxJywgJ1RFWFRVUkUyJ107XG5cbmV4cG9ydCBjb25zdCBURVhUTFVNUFMgPSBbXG4gICAgJ0RFSEFDS0VEJyxcbiAgICAnTUFQSU5GTycsXG4gICAgJ1pNQVBJTkZPJyxcbiAgICAnRU1BUElORk8nLFxuICAgICdETVhHVVMnLFxuICAgICdETVhHVVNDJyxcbiAgICAnV0FESU5GTycsXG4gICAgJ0VNRU5VUycsXG4gICAgJ01VU0lORk8nLFxuICAgICdTTkRJTkZPJyxcbiAgICAnR0xERUZTJyxcbiAgICAnS0VZQ09ORicsXG4gICAgJ1NDUklQVFMnLFxuICAgICdMQU5HVUFHRScsXG4gICAgJ0RFQ09SQVRFJyxcbiAgICAnU0JBUklORk8nLFxuICAgICdNRU5VREVGJ1xuXTtcbmV4cG9ydCBjb25zdCBEQVRBX0xVTVBTID0gW1xuICAgICdQTEFZUEFMJyxcbiAgICAnQ09MT1JNQVAnLFxuICAgICdURVhUVVJFMScsXG4gICAgJ1RFWFRVUkUyJyxcbiAgICAnUE5BTUVTJyxcbiAgICAnRU5ET09NJ1xuXTtcblxuZXhwb3J0IGNvbnN0IERFRkFVTFRfRVhURU5TSU9OID0gJ2xtcCc7XG5leHBvcnQgY29uc3QgRVhURU5TSU9OUyA9IHtcbiAgICB0ZXh0OiAndHh0JyxcbiAgICBtcDM6ICdtcDMnLFxuICAgIG11czogJ211cycsXG4gICAgbWlkaTogJ21pZCcsXG4gICAgcG5nOiAncG5nJ1xufTtcblxuLyogRW52aXJvbm1lbnQgKi9cblxuZXhwb3J0IGNvbnN0IE5PX0JSQU5EX0VOViA9ICdkZXZlbG9wbWVudC1uby1icmFuZCc7XG5cbi8qIFdvcmtlcnMgKi9cblxuZXhwb3J0IGNvbnN0IFNFUlZJQ0VfV09SS0VSX0NPUkUgPSAnc2VydmljZS13b3JrZXItY29yZS5qcyc7XG5cbmV4cG9ydCBjb25zdCBXRUJfV09SS0VSX01BWF9SRVRSSUVTID0gMTtcblxuLyogV2ViIHdvcmtlciBpbnRlcm5hbCBlcnJvcnMgKi9cblxuZXhwb3J0IGNvbnN0IElOVkFMSURfVEVYVCA9ICdJTlZBTElEX1RFWFQnO1xuXG4vKiBUaGVtZXMgKi9cblxuZXhwb3J0IGNvbnN0IERBUktfVEhFTUUgPSAnZGFyayc7XG5cbmV4cG9ydCBjb25zdCBMSUdIVF9USEVNRSA9ICdsaWdodCc7XG5cbi8qIElucHV0IHR5cGVzICovXG5cbmV4cG9ydCBjb25zdCBDSEVDS0JPWCA9ICdjaGVja2JveCc7XG5cbi8qIEZpbGUgZm9ybWF0cyAqL1xuXG5leHBvcnQgY29uc3QgU1VQUE9SVEVEX0ZPUk1BVFMgPSBbJy53YWQnLCAnLnppcCcsICcucGszJywgJy5qc29uJ107XG5cbmV4cG9ydCBjb25zdCBWQUxJRF9GSUxFX0ZPUk1BVFMgPSBbXG4gICAgJycsXG4gICAgJ2FwcGxpY2F0aW9uL3gtZG9vbScsXG4gICAgJ2FwcGxpY2F0aW9uL3ppcCcsXG4gICAgJ2FwcGxpY2F0aW9uL2pzb24nXG5dO1xuXG4vKiBXQUQgdHlwZXMgKi9cblxuZXhwb3J0IGNvbnN0IElXQUQgPSAnSVdBRCc7XG5leHBvcnQgY29uc3QgUFdBRCA9ICdQV0FEJztcbmV4cG9ydCBjb25zdCBWQUxJRF9XQURfVFlQRVMgPSBbSVdBRCwgUFdBRF07XG5cbi8qIEx1bXAgdHlwZXMgKi9cblxuZXhwb3J0IGNvbnN0IE1BUCA9ICdtYXBzJztcblxuZXhwb3J0IGNvbnN0IElOVEVSTUlTU0lPTiA9ICdpbnRlcm1pc3Npb24nO1xuXG5leHBvcnQgY29uc3QgU1RBVFVTX0JBUiA9ICdzdGF0dXMgYmFyJztcblxuZXhwb3J0IGNvbnN0IE1FTlUgPSAnbWVudSc7XG5cbmV4cG9ydCBjb25zdCBJTUFHRV9MVU1QUyA9IFtcbiAgICAncGF0Y2hlcycsXG4gICAgJ2ZsYXRzJyxcbiAgICAnc3ByaXRlcycsXG4gICAgTUVOVSxcbiAgICBJTlRFUk1JU1NJT04sXG4gICAgU1RBVFVTX0JBUlxuXTtcblxuZXhwb3J0IGNvbnN0IFVOQ0FURUdPUklaRUQgPSAndW5jYXRlZ29yaXplZCc7XG5cbi8qIEx1bXAgbmFtZXMgKi9cblxuZXhwb3J0IGNvbnN0IFRISU5HUyA9ICdUSElOR1MnO1xuXG5leHBvcnQgY29uc3QgVEVYVE1BUCA9ICdURVhUTUFQJztcblxuZXhwb3J0IGNvbnN0IEVORE1BUCA9ICdFTkRNQVAnO1xuXG5leHBvcnQgY29uc3QgTUFQX0xVTVBTID0gW1xuICAgIFRISU5HUyxcbiAgICAnTElORURFRlMnLFxuICAgICdTSURFREVGUycsXG4gICAgJ1ZFUlRFWEVTJyxcbiAgICAnU0VHUycsXG4gICAgJ1RFWFRNQVAnLFxuICAgICdTU0VDVE9SUycsXG4gICAgJ05PREVTJyxcbiAgICAnU0VDVE9SUycsXG4gICAgJ1JFSkVDVCcsXG4gICAgJ0JMT0NLTUFQJyxcbiAgICAvLyBIZXhlbiBvbmx5XG4gICAgJ0JFSEFWSU9SJyxcbiAgICAvLyBaRG9vbSBvbmx5PyAob3B0aW9uYWwpXG4gICAgJ1NDUklQVFMnLFxuICAgIC8vIFVuaXZlcnNhbCBEb29tIE1hcCBGb3JtYXQgb25seVxuICAgICdaTk9ERVMnLFxuICAgICdESUFMT0dVRSdcbl07XG5cbmV4cG9ydCBjb25zdCBPUEVOR0xfTUFQX0xVTVBTID0gW1xuICAgICdHTF9WRVJUJyxcbiAgICAnR0xfU0VHUycsXG4gICAgJ0dMX1NTRUNUJyxcbiAgICAnR0xfTk9ERVMnLFxuICAgICdHTF9QVlMnXG5dO1xuXG5leHBvcnQgY29uc3QgU1RBUlRfTUFSS0VSUyA9IG5ldyBSZWdFeHAoL15bMC05YS16QS1aXXswLDJ9X1NUQVJUJC8pO1xuXG5leHBvcnQgY29uc3QgRU5EX01BUktFUlMgPSBuZXcgUmVnRXhwKC9eWzAtOWEtekEtWl17MCwyfV9FTkQkLyk7XG5cbmV4cG9ydCBjb25zdCBURVhUVVJFX0xVTVBTID0gbmV3IFJlZ0V4cCgvXlRFWFRVUkVbMC05YS16QS1aXSQvKTtcblxuZXhwb3J0IGNvbnN0IElOVEVSTUlTU0lPTl9MVU1QUyA9IG5ldyBSZWdFeHAoL15XSVswLTlhLXpBLVpfXXsxLH0kLyk7XG5cbi8vIERvb20gSUlcbmV4cG9ydCBjb25zdCBJTlRFUk1JU1NJT05fTUFQX05BTUVfTFVNUFMgPSBuZXcgUmVnRXhwKFxuICAgIC9eQ1dJTFZbMC05YS16QS1aX117MSx9JC9cbik7XG5cbmV4cG9ydCBjb25zdCBTVEFUVVNfQkFSX0xVTVBTID0gbmV3IFJlZ0V4cCgvXihTVHxBTU18QlJEUl8pWzAtOWEtekEtWl9dezEsfSQvKTtcblxuLyogVW5pcXVlIGx1bXBzICovXG5cbmV4cG9ydCBjb25zdCBBTlNJX0xVTVBTID0gW1xuICAgIC8vIERvb20gb3IgQ2hleCBRdWVzdFxuICAgICdFTkRPT00nLFxuICAgIC8vIEhlcmV0aWNcbiAgICAnRU5EVEVYVCcsXG4gICAgLy8gU3RyaWZlXG4gICAgJ0VORFNUUkYnLFxuICAgIC8vIEJvb21cbiAgICAnRU5EQk9PTSdcbiAgICAvLyBsYWNrIG9mIEFOU0kgbHVtcCBpbiBJV0FEID0gSGV4ZW5cbl07XG5cbmV4cG9ydCBjb25zdCBNQVBJTkZPID0gWydNQVBJTkZPJywgJ1pNQVBJTkZPJ107XG5cbmV4cG9ydCBjb25zdCBQTEFZUEFMID0gJ1BMQVlQQUwnO1xuZXhwb3J0IGNvbnN0IENPTE9STUFQID0gJ0NPTE9STUFQJztcblxuZXhwb3J0IGNvbnN0IFBOQU1FUyA9ICdQTkFNRVMnO1xuXG5leHBvcnQgY29uc3QgU0JBUklORk8gPSAnU0JBUklORk8nO1xuXG4vLyBIZXhlbiBvbmx5XG5leHBvcnQgY29uc3QgU05ESU5GTyA9ICdTTkRJTkZPJztcblxuZXhwb3J0IGNvbnN0IE1FTlVfU0NSRUVOUyA9IFsnVElUTEVQSUMnLCAnSEVMUCcsICdIRUxQMScsICdIRUxQMicsICdDUkVESVQnXTtcblxuZXhwb3J0IGNvbnN0IElOVEVSX1NDUkVFTlMgPSBbXG4gICAgJ0lOVEVSUElDJyxcbiAgICAvLyBEb29tIDEgcmVnaXN0ZXJlZFxuICAgICdFTkRQSUMnLFxuICAgICdWSUNUT1JZMicsXG4gICAgJ1BGVUIxJyxcbiAgICAnUEZVQjInLFxuICAgIC8vIERvb20gMlxuICAgICdCT1NTQkFDSydcbl07XG5cbmV4cG9ydCBjb25zdCBNVVNJQ19MVU1QUyA9IFsnR0VOTUlESScsICdETVhHVVMnLCAnRE1YR1VTQyddO1xuXG5leHBvcnQgY29uc3QgREVNT19MVU1QUyA9IFsnREVNTzEnLCAnREVNTzInLCAnREVNTzMnLCAnREVNTzQnXTtcblxuZXhwb3J0IGNvbnN0IEVORF9MVU1QUyA9IG5ldyBSZWdFeHAoL15FTkRbMC05XXsxLH0kLyk7XG5cbi8qIEx1bXAgb3JpZ2luYWwgZm9ybWF0cyAqL1xuXG5leHBvcnQgY29uc3QgQU5TSSA9ICdBTlNJJztcblxuLyogTHVtcCBzcGVjaWFsIHZhbHVlcyAqL1xuXG5leHBvcnQgY29uc3QgTFVNUF9JTkRFWF9FTlRSWV9TSVpFID0gMTY7XG5leHBvcnQgY29uc3QgTFVNUF9JTkRFWF9FTlRSWV9PRkZTRVRfVE9fTFVNUF9TSVpFID0gNDtcbmV4cG9ydCBjb25zdCBMVU1QX0lOREVYX0VOVFJZX09GRlNFVF9UT19MVU1QX05BTUUgPSA4O1xuXG5leHBvcnQgY29uc3QgQ09MT1JfQ09VTlRfUEVSX1BBTEVUVEUgPSAyNTY7XG5leHBvcnQgY29uc3QgUEFMRVRURV9TSVpFID0gNzY4O1xuZXhwb3J0IGNvbnN0IENPTE9STUFQX1NJWkUgPSAyNTY7XG5cbmV4cG9ydCBjb25zdCBCWVRFU19QRVJfQ09MT1IgPSAzO1xuZXhwb3J0IGNvbnN0IEdSRUVOX0NPTE9SX09GRlNFVCA9IDE7XG5leHBvcnQgY29uc3QgQkxVRV9DT0xPUl9PRkZTRVQgPSAyO1xuXG5leHBvcnQgY29uc3QgRkxBVF9ESU1FTlNJT05TID0gNjQ7XG5cbmV4cG9ydCBjb25zdCBJTUFHRV9EQVRBX0hFQURFUl9TSVpFID0gODtcbmV4cG9ydCBjb25zdCBJTUFHRV9EQVRBX0JPVU5EQVJZID0gMjU1O1xuXG5leHBvcnQgY29uc3QgVFJBTlNQQVJFTlRfUElYRUwgPSAtMTtcblxuZXhwb3J0IGNvbnN0IEhFWEVOX1NPVU5EX0FSQ0hJVkVfUEFUSCA9ICckQVJDSElWRVBBVEgnO1xuXG5leHBvcnQgY29uc3QgSEVYRU5fU09VTkRfUkVHSVNURVJFRCA9ICckUkVHSVNURVJFRCc7XG5cbmV4cG9ydCBjb25zdCBIRVhFTl9NVVNJQ19LRVlXT1JEID0gJyRNQVAnO1xuXG4vKiBNVVMgLT4gTUlESSBjb252ZXJzaW9uICovXG5cbmV4cG9ydCBjb25zdCBNVVNfSEVBREVSID0gJ01VUyc7XG5leHBvcnQgY29uc3QgTVVTX0hFQURFUl9TSUdOQVRVUkUgPSBbXG4gICAgJ00nLmNoYXJDb2RlQXQoMCksXG4gICAgJ1UnLmNoYXJDb2RlQXQoMCksXG4gICAgJ1MnLmNoYXJDb2RlQXQoMCksXG4gICAgMHgxYVxuXS5qb2luKCcgJyk7XG5leHBvcnQgY29uc3QgTUlESV9IRUFERVIgPSAnTVRoZCc7XG5leHBvcnQgY29uc3QgTUlESV9IRUFERVJfU0laRSA9IDQ7XG5leHBvcnQgY29uc3QgTUlESV9IRUFERVJfREFUQSA9IFtcbiAgICAnTScuY2hhckNvZGVBdCgwKSxcbiAgICAnVCcuY2hhckNvZGVBdCgwKSxcbiAgICAnaCcuY2hhckNvZGVBdCgwKSxcbiAgICAnZCcuY2hhckNvZGVBdCgwKSwgLy8gTWFpbiBoZWFkZXJcbiAgICAweDAwLFxuICAgIDB4MDAsXG4gICAgMHgwMCxcbiAgICAweDA2LCAvLyBIZWFkZXIgc2l6ZVxuICAgIDB4MDAsXG4gICAgMHgwMCwgLy8gTUlESSB0eXBlICgwKVxuICAgIDB4MDAsXG4gICAgMHgwMSwgLy8gTnVtYmVyIG9mIHRyYWNrc1xuICAgIDB4MDAsXG4gICAgMHg0NiwgLy8gUmVzb2x1dGlvblxuICAgICdNJy5jaGFyQ29kZUF0KDApLFxuICAgICdUJy5jaGFyQ29kZUF0KDApLFxuICAgICdyJy5jaGFyQ29kZUF0KDApLFxuICAgICdrJy5jaGFyQ29kZUF0KDApLCAvLyBTdGFydCBvZiB0cmFja1xuICAgIDB4MDAsXG4gICAgMHgwMCxcbiAgICAweDAwLFxuICAgIDB4MDAgLy8gUGxhY2Vob2xkZXIgZm9yIHRyYWNrIGxlbmd0aFxuXTtcblxuZXhwb3J0IGNvbnN0IE1VU19OVU1fQ0hBTk5FTFMgPSAxNjtcbmV4cG9ydCBjb25zdCBNVVNfUEVSQ1VTU0lPTl9DSEFOTkVMID0gMTU7XG5leHBvcnQgY29uc3QgTUlESV9QRVJDVVNTSU9OX0NIQU5ORUwgPSA5O1xuZXhwb3J0IGNvbnN0IE1JRElfVFJBQ0tMRU5HVEhfT0ZTID0gMTg7XG5cbmV4cG9ydCBjb25zdCBNSURJX0NPTlRST0xMRVJfTUFQID0gW1xuICAgIDB4MDAsXG4gICAgMHgyMCxcbiAgICAweDAxLFxuICAgIDB4MDcsXG4gICAgMHgwYSxcbiAgICAweDBiLFxuICAgIDB4NWIsXG4gICAgMHg1ZCxcbiAgICAweDQwLFxuICAgIDB4NDMsXG4gICAgMHg3OCxcbiAgICAweDdiLFxuICAgIDB4N2UsXG4gICAgMHg3ZixcbiAgICAweDc5XG5dO1xuXG4vLyBNVVMgZXZlbnQgY29kZXNcbmV4cG9ydCBjb25zdCBNVVNfUkVMRUFTRV9LRVkgPSAweDAwO1xuZXhwb3J0IGNvbnN0IE1VU19QUkVTU19LRVkgPSAweDEwO1xuZXhwb3J0IGNvbnN0IE1VU19QSVRDSF9XSEVFTCA9IDB4MjA7XG5leHBvcnQgY29uc3QgTVVTX1NZU1RFTV9FVkVOVCA9IDB4MzA7XG5leHBvcnQgY29uc3QgTVVTX0NIQU5HRV9DT05UUk9MTEVSID0gMHg0MDtcbmV4cG9ydCBjb25zdCBNVVNfU0NPUkVfRU5EID0gMHg2MDtcblxuLy8gTUlESSBldmVudCBjb2Rlc1xuZXhwb3J0IGNvbnN0IE1JRElfUkVMRUFTRV9LRVkgPSAweDgwO1xuZXhwb3J0IGNvbnN0IE1JRElfUFJFU1NfS0VZID0gMHg5MDtcbmV4cG9ydCBjb25zdCBNSURJX0NIQU5HRV9DT05UUk9MTEVSID0gMHhiMDtcbmV4cG9ydCBjb25zdCBNSURJX0NIQU5HRV9QQVRDSCA9IDB4YzA7XG5leHBvcnQgY29uc3QgTUlESV9QSVRDSF9XSEVFTCA9IDB4ZTA7XG5cbi8qIE1JREkgcGxheWVyICovXG5cbmV4cG9ydCBjb25zdCBNQVhfSTE2ID0gMiAqKiAxNTtcblxuZXhwb3J0IGNvbnN0IE1JRElfQVVESU9fQlVGRkVSX1NJWkUgPSA4MTkyO1xuXG4vLyBzaWduZWQgMTYtYml0IHNhbXBsZXNcbmV4cG9ydCBjb25zdCBNSURJX0FVRElPX1MxNkxTQiA9IDB4ODAxMDtcblxuZXhwb3J0IGNvbnN0IE1JRElfUEFUQ0hfVVJMID0gJy9wdWJsaWMvbWlkaS9wYXQvJztcblxuZXhwb3J0IGNvbnN0IE1JRElfUExBWUVSX01FU1NBR0VfUFJFRklYID0gJ01pZGkgcGxheWVyOic7XG5cbmV4cG9ydCBjb25zdCBNSURJX0VSUk9SID0gJ01JRElfRVJST1InO1xuXG5leHBvcnQgY29uc3QgTUlESV9TVEFUVVMgPSAnTUlESV9TVEFUVVMnO1xuXG5leHBvcnQgY29uc3QgTUlESV9QUkVMT0FEID0gJ01JRElfUFJFTE9BRCc7XG5cbmV4cG9ydCBjb25zdCBNSURJX0xPQURfRklMRSA9ICdNSURJX0xPQURfRklMRSc7XG5cbmV4cG9ydCBjb25zdCBNSURJX0xPQURfUEFUQ0ggPSAnTUlESV9MT0FEX1BBVENIJztcblxuZXhwb3J0IGNvbnN0IE1JRElfUExBWSA9ICdNSURJX1BMQVknO1xuXG5leHBvcnQgY29uc3QgTUlESV9QQVVTRSA9ICdNSURJX1BBVVNFJztcblxuZXhwb3J0IGNvbnN0IE1JRElfUkVTVU1FID0gJ01JRElfUkVTVU1FJztcblxuZXhwb3J0IGNvbnN0IE1JRElfU1RPUCA9ICdNSURJX1NUT1AnO1xuXG5leHBvcnQgY29uc3QgTUlESV9FTkQgPSAnTUlESV9FTkQnO1xuXG4vKiBETVggLT4gUENNIGNvbnZlcnNpb24gKi9cblxuZXhwb3J0IGNvbnN0IERNWF9IRUFERVJfU0laRSA9IDE4O1xuXG5leHBvcnQgY29uc3QgRE1YX1RBSUxfUEFERElORyA9IDI7XG5cbi8qIFBDTSBQbGF5ZXIgKi9cblxuZXhwb3J0IGNvbnN0IERFRkFVTFRfUENNX1NBTVBMRV9SQVRFID0gMTEwMjU7XG5cbmV4cG9ydCBjb25zdCBERUZBVUxUX1BDTV9DT05GSUdVUkFUSU9OID0ge1xuICAgIGVuY29kaW5nOiAnOGJpdCcsXG4gICAgY2hhbm5lbHM6IDEsXG4gICAgdm9sdW1lOiAxLFxuICAgIGxvZ2dpbmc6IGZhbHNlXG59O1xuXG5leHBvcnQgY29uc3QgUENNX01BWF9WQUxVRVMgPSB7XG4gICAgJzhiaXQnOiAyNTUsXG4gICAgJzE2Yml0JzogNjU1MzUsXG4gICAgJzMyYml0JzogNDI5NDk2NzI5NSxcbiAgICAnMzJiaXRGbG9hdCc6IDFcbn07XG5cbmV4cG9ydCBjb25zdCBQQ01fVFlQRURfQVJSQVlTID0ge1xuICAgICc4Yml0JzogVWludDhBcnJheSxcbiAgICAnMTZiaXQnOiBVaW50MTZBcnJheSxcbiAgICAnMzJiaXQnOiBVaW50MzJBcnJheSxcbiAgICAnMzJiaXRGbG9hdCc6IEZsb2F0MzJBcnJheVxufTtcblxuZXhwb3J0IGNvbnN0IFBDTV9QTEFZRVJfTUVTU0FHRV9QUkVGSVggPSAnUENNIHBsYXllcjonO1xuXG5leHBvcnQgY29uc3QgUENNX1NUQVRVUyA9ICdQQ01fU1RBVFVTJztcblxuZXhwb3J0IGNvbnN0IFBDTV9FUlJPUiA9ICdQQ01fRVJST1InO1xuXG5leHBvcnQgY29uc3QgUENNX1BMQVkgPSAnUENNX1BMQVknO1xuXG5leHBvcnQgY29uc3QgUENNX1BBVVNFID0gJ1BDTV9QQVVTRSc7XG5cbmV4cG9ydCBjb25zdCBQQ01fU1RPUCA9ICdQQ01fU1RPUCc7XG5cbmV4cG9ydCBjb25zdCBQQ01fRU5EID0gJ1BDTV9FTkQnO1xuXG4vKiBNYXAgZGF0YSAqL1xuXG5leHBvcnQgY29uc3QgTUFQX1BBRERJTkcgPSA2NDtcblxuZXhwb3J0IGNvbnN0IE1BUF9EQVRBX1NDSEVNQVMgPSB7XG4gICAgVEhJTkdTOiB7XG4gICAgICAgIHNpemU6IDEwLFxuICAgICAgICBwcm9wZXJ0aWVzOiBbXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgbmFtZTogJ3gnLFxuICAgICAgICAgICAgICAgIGZvcm1hdDogJ0ludDE2J1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBuYW1lOiAneScsXG4gICAgICAgICAgICAgICAgZm9ybWF0OiAnSW50MTYnXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIG5hbWU6ICdhbmdsZScsXG4gICAgICAgICAgICAgICAgZm9ybWF0OiAnSW50MTYnXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIG5hbWU6ICd0eXBlJyxcbiAgICAgICAgICAgICAgICBmb3JtYXQ6ICdJbnQxNidcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgbmFtZTogJ2ZsYWdzJyxcbiAgICAgICAgICAgICAgICBmb3JtYXQ6ICdJbnQxNidcbiAgICAgICAgICAgIH1cbiAgICAgICAgXVxuICAgIH0sXG4gICAgVkVSVEVYRVM6IHtcbiAgICAgICAgc2l6ZTogNCxcbiAgICAgICAgcHJvcGVydGllczogW1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIG5hbWU6ICd4JyxcbiAgICAgICAgICAgICAgICBmb3JtYXQ6ICdJbnQxNidcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgbmFtZTogJ3knLFxuICAgICAgICAgICAgICAgIGZvcm1hdDogJ0ludDE2J1xuICAgICAgICAgICAgfVxuICAgICAgICBdXG4gICAgfSxcbiAgICBMSU5FREVGUzoge1xuICAgICAgICBzaXplOiAxNCxcbiAgICAgICAgcHJvcGVydGllczogW1xuICAgICAgICAgICAgeyBuYW1lOiAndmVydGV4MScgfSxcbiAgICAgICAgICAgIHsgbmFtZTogJ3ZlcnRleDInIH0sXG4gICAgICAgICAgICB7IG5hbWU6ICdmbGFncycgfSxcbiAgICAgICAgICAgIHsgbmFtZTogJ2FjdGlvbicgfSxcbiAgICAgICAgICAgIHsgbmFtZTogJ3RhZycgfSxcbiAgICAgICAgICAgIHsgbmFtZTogJ3JpZ2h0U2lkZWRlZicgfSxcbiAgICAgICAgICAgIHsgbmFtZTogJ2xlZnRTaWRlZGVmJyB9XG4gICAgICAgIF1cbiAgICB9LFxuICAgIFNJREVERUZTOiB7XG4gICAgICAgIHNpemU6IDMwLFxuICAgICAgICBwcm9wZXJ0aWVzOiBbXG4gICAgICAgICAgICB7IG5hbWU6ICd4T2Zmc2V0JyB9LFxuICAgICAgICAgICAgeyBuYW1lOiAneU9mZnNldCcgfSxcbiAgICAgICAgICAgIHsgbmFtZTogJ3VwcGVyJywgZm9ybWF0OiAnbmFtZScgfSxcbiAgICAgICAgICAgIHsgbmFtZTogJ2xvd2VyJywgZm9ybWF0OiAnbmFtZScgfSxcbiAgICAgICAgICAgIHsgbmFtZTogJ21pZGRsZScsIGZvcm1hdDogJ25hbWUnIH0sXG4gICAgICAgICAgICB7IG5hbWU6ICdzZWN0b3InIH1cbiAgICAgICAgXVxuICAgIH0sXG4gICAgU0VDVE9SUzoge1xuICAgICAgICBzaXplOiAyNixcbiAgICAgICAgcHJvcGVydGllczogW1xuICAgICAgICAgICAgeyBuYW1lOiAnekZsb29yJyB9LFxuICAgICAgICAgICAgeyBuYW1lOiAnekNlaWwnIH0sXG4gICAgICAgICAgICB7IG5hbWU6ICdmbG9vckZsYXQnLCBmb3JtYXQ6ICduYW1lJyB9LFxuICAgICAgICAgICAgeyBuYW1lOiAnY2VpbEZsYXQnLCBmb3JtYXQ6ICduYW1lJyB9LFxuICAgICAgICAgICAgeyBuYW1lOiAnbGlnaHQnIH0sXG4gICAgICAgICAgICB7IG5hbWU6ICd0eXBlJyB9LFxuICAgICAgICAgICAgeyBuYW1lOiAndGFnJyB9XG4gICAgICAgIF1cbiAgICB9LFxuICAgIFNFR1M6IHtcbiAgICAgICAgc2l6ZTogMTIsXG4gICAgICAgIHByb3BlcnRpZXM6IFtcbiAgICAgICAgICAgIHsgbmFtZTogJ3ZlcnRleDEnIH0sXG4gICAgICAgICAgICB7IG5hbWU6ICd2ZXJ0ZXgyJyB9LFxuICAgICAgICAgICAgeyBuYW1lOiAnYW5nbGUnIH0sXG4gICAgICAgICAgICB7IG5hbWU6ICdsaW5lZGVmJyB9LFxuICAgICAgICAgICAgeyBuYW1lOiAnZGlyZWN0aW9uJyB9LFxuICAgICAgICAgICAgeyBuYW1lOiAnb2Zmc2V0JyB9XG4gICAgICAgIF1cbiAgICB9LFxuICAgIFNTRUNUT1JTOiB7XG4gICAgICAgIHNpemU6IDQsXG4gICAgICAgIHByb3BlcnRpZXM6IFt7IG5hbWU6ICdzZWdDb3VudCcgfSwgeyBuYW1lOiAnZmlyc3QnIH1dXG4gICAgfSxcbiAgICBOT0RFUzoge1xuICAgICAgICBzaXplOiAyOCxcbiAgICAgICAgcHJvcGVydGllczogW1xuICAgICAgICAgICAgeyBuYW1lOiAncGFydGl0aW9uWCcgfSxcbiAgICAgICAgICAgIHsgbmFtZTogJ3BhcnRpdGlvblknIH0sXG4gICAgICAgICAgICB7IG5hbWU6ICdjaGFuZ2VYJyB9LFxuICAgICAgICAgICAgeyBuYW1lOiAnY2hhbmdlWScgfSxcbiAgICAgICAgICAgIC8vIGRpZmZlcmVudCBmb3JtIG9yaWdpbmFsXG4gICAgICAgICAgICB7IG5hbWU6ICdib3VuZHNSaWdodFRvcCcgfSxcbiAgICAgICAgICAgIHsgbmFtZTogJ2JvdW5kc1JpZ2h0Qm90dG9tJyB9LFxuICAgICAgICAgICAgeyBuYW1lOiAnYm91bmRzUmlnaHRMZWZ0JyB9LFxuICAgICAgICAgICAgeyBuYW1lOiAnYm91bmRzUmlnaHRSaWdodCcgfSxcbiAgICAgICAgICAgIC8vIGRpZmZlcmVudCBmb3JtIG9yaWdpbmFsXG4gICAgICAgICAgICB7IG5hbWU6ICdib3VuZHNMZWZ0VG9wJyB9LFxuICAgICAgICAgICAgeyBuYW1lOiAnYm91bmRzTGVmdEJvdHRvbScgfSxcbiAgICAgICAgICAgIHsgbmFtZTogJ2JvdW5kc0xlZnRMZWZ0JyB9LFxuICAgICAgICAgICAgeyBuYW1lOiAnYm91bmRzTGVmdFJpZ2h0JyB9LFxuICAgICAgICAgICAgeyBuYW1lOiAnY2hpbGRSaWdodCcgfSxcbiAgICAgICAgICAgIHsgbmFtZTogJ2NoaWxkTGVmdCcgfVxuICAgICAgICBdXG4gICAgfVxufTtcblxuZXhwb3J0IGNvbnN0IEhFWEVOX01BUF9EQVRBX1NDSEVNQVMgPSB7XG4gICAgVEhJTkdTOiB7XG4gICAgICAgIHNpemU6IDIwLFxuICAgICAgICBwcm9wZXJ0aWVzOiBbXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgbmFtZTogJ3RpZCcsXG4gICAgICAgICAgICAgICAgZm9ybWF0OiAnSW50MTYnXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIG5hbWU6ICd4JyxcbiAgICAgICAgICAgICAgICBmb3JtYXQ6ICdJbnQxNidcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgbmFtZTogJ3knLFxuICAgICAgICAgICAgICAgIGZvcm1hdDogJ0ludDE2J1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBuYW1lOiAneicsXG4gICAgICAgICAgICAgICAgZm9ybWF0OiAnSW50MTYnXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIG5hbWU6ICdhbmdsZScsXG4gICAgICAgICAgICAgICAgZm9ybWF0OiAnSW50MTYnXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIG5hbWU6ICd0eXBlJyxcbiAgICAgICAgICAgICAgICBmb3JtYXQ6ICdJbnQxNidcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgbmFtZTogJ2ZsYWdzJyxcbiAgICAgICAgICAgICAgICBmb3JtYXQ6ICdJbnQxNidcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgbmFtZTogJ3NwZWNpYWwnLFxuICAgICAgICAgICAgICAgIGZvcm1hdDogJ0ludDgnLFxuICAgICAgICAgICAgICAgIGxpdHRsZUVuZGlhbjogZmFsc2VcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAvLyBkaWZmZXJlbnQgZnJvbSBvcmlnaW5hbFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIG5hbWU6ICdhcmcwJyxcbiAgICAgICAgICAgICAgICBmb3JtYXQ6ICdJbnQ4JyxcbiAgICAgICAgICAgICAgICBsaXR0bGVFbmRpYW46IGZhbHNlXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIG5hbWU6ICdhcmcxJyxcbiAgICAgICAgICAgICAgICBmb3JtYXQ6ICdJbnQ4JyxcbiAgICAgICAgICAgICAgICBsaXR0bGVFbmRpYW46IGZhbHNlXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIG5hbWU6ICdhcmcyJyxcbiAgICAgICAgICAgICAgICBmb3JtYXQ6ICdJbnQ4JyxcbiAgICAgICAgICAgICAgICBsaXR0bGVFbmRpYW46IGZhbHNlXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIG5hbWU6ICdhcmczJyxcbiAgICAgICAgICAgICAgICBmb3JtYXQ6ICdJbnQ4JyxcbiAgICAgICAgICAgICAgICBsaXR0bGVFbmRpYW46IGZhbHNlXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIG5hbWU6ICdhcmc0JyxcbiAgICAgICAgICAgICAgICBmb3JtYXQ6ICdJbnQ4JyxcbiAgICAgICAgICAgICAgICBsaXR0bGVFbmRpYW46IGZhbHNlXG4gICAgICAgICAgICB9XG4gICAgICAgIF1cbiAgICB9LFxuICAgIExJTkVERUZTOiB7XG4gICAgICAgIHNpemU6IDE2LFxuICAgICAgICBwcm9wZXJ0aWVzOiBbXG4gICAgICAgICAgICB7IG5hbWU6ICd2ZXJ0ZXgxJyB9LFxuICAgICAgICAgICAgeyBuYW1lOiAndmVydGV4MicgfSxcbiAgICAgICAgICAgIHsgbmFtZTogJ2ZsYWdzJyB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIG5hbWU6ICdhY3Rpb24nLFxuICAgICAgICAgICAgICAgIGZvcm1hdDogJ1VpbnQ4JyxcbiAgICAgICAgICAgICAgICBsaXR0bGVFbmRpYW46IGZhbHNlXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgLy8gZGlmZmVyZW50IGZyb20gb3JpZ2luYWxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBuYW1lOiAnYXJnMCcsXG4gICAgICAgICAgICAgICAgZm9ybWF0OiAnSW50OCcsXG4gICAgICAgICAgICAgICAgbGl0dGxlRW5kaWFuOiBmYWxzZVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBuYW1lOiAnYXJnMScsXG4gICAgICAgICAgICAgICAgZm9ybWF0OiAnSW50OCcsXG4gICAgICAgICAgICAgICAgbGl0dGxlRW5kaWFuOiBmYWxzZVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBuYW1lOiAnYXJnMicsXG4gICAgICAgICAgICAgICAgZm9ybWF0OiAnSW50OCcsXG4gICAgICAgICAgICAgICAgbGl0dGxlRW5kaWFuOiBmYWxzZVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBuYW1lOiAnYXJnMycsXG4gICAgICAgICAgICAgICAgZm9ybWF0OiAnSW50OCcsXG4gICAgICAgICAgICAgICAgbGl0dGxlRW5kaWFuOiBmYWxzZVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBuYW1lOiAnYXJnNCcsXG4gICAgICAgICAgICAgICAgZm9ybWF0OiAnSW50OCcsXG4gICAgICAgICAgICAgICAgbGl0dGxlRW5kaWFuOiBmYWxzZVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHsgbmFtZTogJ3JpZ2h0U2lkZWRlZicgfSxcbiAgICAgICAgICAgIHsgbmFtZTogJ2xlZnRTaWRlZGVmJyB9XG4gICAgICAgIF1cbiAgICB9XG59O1xuXG5leHBvcnQgY29uc3QgREVGQVVMVF9NQVBfUEFMRVRURSA9IHtcbiAgICBiYWNrZ3JvdW5kOiB7XG4gICAgICAgIGJsdWU6IDAsXG4gICAgICAgIGdyZWVuOiAwLFxuICAgICAgICByZWQ6IDBcbiAgICB9LFxuICAgIHNvbGlkV2FsbDoge1xuICAgICAgICBibHVlOiAwLFxuICAgICAgICBncmVlbjogMCxcbiAgICAgICAgcmVkOiAyNTVcbiAgICB9LFxuICAgIGxvd2VyV2FsbDoge1xuICAgICAgICBibHVlOiA3NSxcbiAgICAgICAgZ3JlZW46IDEyMyxcbiAgICAgICAgcmVkOiAxOTFcbiAgICB9LFxuICAgIHVwcGVyV2FsbDoge1xuICAgICAgICBibHVlOiAwLFxuICAgICAgICBncmVlbjogMjU1LFxuICAgICAgICByZWQ6IDI1NVxuICAgIH0sXG4gICAgc2FtZUhlaWdodDoge1xuICAgICAgICBibHVlOiAxMzEsXG4gICAgICAgIGdyZWVuOiAxMzEsXG4gICAgICAgIHJlZDogMTMxXG4gICAgfVxufTtcblxuLyogQU5TSSBjb252ZXJzaW9uICovXG5cbmV4cG9ydCBjb25zdCBBTlNJX0NPREVfUEFHRV80MzdfVEFCTEVTID0gW1xuICAgICcnLFxuICAgICfimLonLFxuICAgICfimLsnLFxuICAgICfimaUnLFxuICAgICfimaYnLFxuICAgICfimaMnLFxuICAgICfimaAnLFxuICAgICfigKInLFxuICAgICfil5gnLFxuICAgICfil4snLFxuICAgICfil5knLFxuICAgICfimYInLFxuICAgICfimYAnLFxuICAgICfimaonLFxuICAgICfimasnLFxuICAgICfimLwnLFxuICAgICfilronLFxuICAgICfil4QnLFxuICAgICfihpUnLFxuICAgICfigLwnLFxuICAgICfCticsXG4gICAgJ8KnJyxcbiAgICAn4pasJyxcbiAgICAn4oaoJyxcbiAgICAn4oaRJyxcbiAgICAn4oaTJyxcbiAgICAn4oaSJyxcbiAgICAn4oaQJyxcbiAgICAn4oifJyxcbiAgICAn4oaUJyxcbiAgICAn4payJyxcbiAgICAn4pa8JyxcbiAgICAnICcsXG4gICAgJyEnLFxuICAgICdcIicsXG4gICAgJyMnLFxuICAgICckJyxcbiAgICAnJScsXG4gICAgJyYnLFxuICAgIFwiJ1wiLFxuICAgICcoJyxcbiAgICAnKScsXG4gICAgJyonLFxuICAgICcrJyxcbiAgICAnLCcsXG4gICAgJy0nLFxuICAgICcuJyxcbiAgICAnLycsXG4gICAgJzAnLFxuICAgICcxJyxcbiAgICAnMicsXG4gICAgJzMnLFxuICAgICc0JyxcbiAgICAnNScsXG4gICAgJzYnLFxuICAgICc3JyxcbiAgICAnOCcsXG4gICAgJzknLFxuICAgICc6JyxcbiAgICAnOycsXG4gICAgJzwnLFxuICAgICc9JyxcbiAgICAnPicsXG4gICAgJz8nLFxuICAgICdAJyxcbiAgICAnQScsXG4gICAgJ0InLFxuICAgICdDJyxcbiAgICAnRCcsXG4gICAgJ0UnLFxuICAgICdGJyxcbiAgICAnRycsXG4gICAgJ0gnLFxuICAgICdJJyxcbiAgICAnSicsXG4gICAgJ0snLFxuICAgICdMJyxcbiAgICAnTScsXG4gICAgJ04nLFxuICAgICdPJyxcbiAgICAnUCcsXG4gICAgJ1EnLFxuICAgICdSJyxcbiAgICAnUycsXG4gICAgJ1QnLFxuICAgICdVJyxcbiAgICAnVicsXG4gICAgJ1cnLFxuICAgICdYJyxcbiAgICAnWScsXG4gICAgJ1onLFxuICAgICdbJyxcbiAgICAnXFxcXCcsXG4gICAgJ10nLFxuICAgICdeJyxcbiAgICAnXycsXG4gICAgJ2AnLFxuICAgICdhJyxcbiAgICAnYicsXG4gICAgJ2MnLFxuICAgICdkJyxcbiAgICAnZScsXG4gICAgJ2YnLFxuICAgICdnJyxcbiAgICAnaCcsXG4gICAgJ2knLFxuICAgICdqJyxcbiAgICAnaycsXG4gICAgJ2wnLFxuICAgICdtJyxcbiAgICAnbicsXG4gICAgJ28nLFxuICAgICdwJyxcbiAgICAncScsXG4gICAgJ3InLFxuICAgICdzJyxcbiAgICAndCcsXG4gICAgJ3UnLFxuICAgICd2JyxcbiAgICAndycsXG4gICAgJ3gnLFxuICAgICd5JyxcbiAgICAneicsXG4gICAgJ3snLFxuICAgICd8JyxcbiAgICAnfScsXG4gICAgJ34nLFxuICAgICfijIInLFxuICAgICfDhycsXG4gICAgJ8O8JyxcbiAgICAnw6knLFxuICAgICfDoicsXG4gICAgJ8OkJyxcbiAgICAnw6AnLFxuICAgICfDpScsXG4gICAgJ8OnJyxcbiAgICAnw6onLFxuICAgICfDqycsXG4gICAgJ8OoJyxcbiAgICAnw68nLFxuICAgICfDricsXG4gICAgJ8OsJyxcbiAgICAnw4QnLFxuICAgICfDhScsXG4gICAgJ8OJJyxcbiAgICAnw6YnLFxuICAgICfDhicsXG4gICAgJ8O0JyxcbiAgICAnw7YnLFxuICAgICfDsicsXG4gICAgJ8O7JyxcbiAgICAnw7knLFxuICAgICfDvycsXG4gICAgJ8OWJyxcbiAgICAnw5wnLFxuICAgICfCoicsXG4gICAgJ8KjJyxcbiAgICAnwqUnLFxuICAgICfigqcnLFxuICAgICfGkicsXG4gICAgJ8OhJyxcbiAgICAnw60nLFxuICAgICfDsycsXG4gICAgJ8O6JyxcbiAgICAnw7EnLFxuICAgICfDkScsXG4gICAgJ8KqJyxcbiAgICAnwronLFxuICAgICfCvycsXG4gICAgJ+KMkCcsXG4gICAgJ8KsJyxcbiAgICAnwr0nLFxuICAgICfCvCcsXG4gICAgJ8KhJyxcbiAgICAnwqsnLFxuICAgICfCuycsXG4gICAgJ+KWkScsXG4gICAgJ+KWkicsXG4gICAgJ+KWkycsXG4gICAgJ+KUgicsXG4gICAgJ+KUpCcsXG4gICAgJ+KVoScsXG4gICAgJ+KVoicsXG4gICAgJ+KVlicsXG4gICAgJ+KVlScsXG4gICAgJ+KVoycsXG4gICAgJ+KVkScsXG4gICAgJ+KVlycsXG4gICAgJ+KVnScsXG4gICAgJ+KVnCcsXG4gICAgJ+KVmycsXG4gICAgJ+KUkCcsXG4gICAgJ+KUlCcsXG4gICAgJ+KUtCcsXG4gICAgJ+KUrCcsXG4gICAgJ+KUnCcsXG4gICAgJ+KUgCcsXG4gICAgJ+KUvCcsXG4gICAgJ+KVnicsXG4gICAgJ+KVnycsXG4gICAgJ+KVmicsXG4gICAgJ+KVlCcsXG4gICAgJ+KVqScsXG4gICAgJ+KVpicsXG4gICAgJ+KVoCcsXG4gICAgJ+KVkCcsXG4gICAgJ+KVrCcsXG4gICAgJ+KVpycsXG4gICAgJ+KVqCcsXG4gICAgJ+KVpCcsXG4gICAgJ+KVpScsXG4gICAgJ+KVmScsXG4gICAgJ+KVmCcsXG4gICAgJ+KVkicsXG4gICAgJ+KVkycsXG4gICAgJ+KVqycsXG4gICAgJ+KVqicsXG4gICAgJ+KUmCcsXG4gICAgJ+KUjCcsXG4gICAgJ+KWiCcsXG4gICAgJ+KWhCcsXG4gICAgJ+KWjCcsXG4gICAgJ+KWkCcsXG4gICAgJ+KWgCcsXG4gICAgJ86xJyxcbiAgICAnw58nLFxuICAgICfOkycsXG4gICAgJ8+AJyxcbiAgICAnzqMnLFxuICAgICfPgycsXG4gICAgJ8K1JyxcbiAgICAnz4QnLFxuICAgICfOpicsXG4gICAgJ86YJyxcbiAgICAnzqknLFxuICAgICfOtCcsXG4gICAgJ+KInicsXG4gICAgJ8+GJyxcbiAgICAnzrUnLFxuICAgICfiiKknLFxuICAgICfiiaEnLFxuICAgICfCsScsXG4gICAgJ+KJpScsXG4gICAgJ+KJpCcsXG4gICAgJ+KMoCcsXG4gICAgJ+KMoScsXG4gICAgJ8O3JyxcbiAgICAn4omIJyxcbiAgICAnwrAnLFxuICAgICfiiJknLFxuICAgICfCtycsXG4gICAgJ+KImicsXG4gICAgJ+KBvycsXG4gICAgJ8KyJyxcbiAgICAn4pagJyxcbiAgICAnICdcbl07XG5cbmV4cG9ydCBjb25zdCBBTlNJX0JBQ0tHUk9VTkRfQ09MT1JfQ09ERVMgPSBbXG4gICAgJ2JsYWNrJyxcbiAgICAnYmx1ZScsXG4gICAgJ2dyZWVuJyxcbiAgICAnY3lhbicsXG4gICAgJ3JlZCcsXG4gICAgJ21hZ2VudGEnLFxuICAgICdicm93bicsXG4gICAgJ2xpZ2h0LWdyYXknXG5dO1xuXG5leHBvcnQgY29uc3QgQU5TSV9GT1JFR1JPVU5EX0NPTE9SX0NPREVTID0gW1xuICAgICdibGFjaycsXG4gICAgJ2JsdWUnLFxuICAgICdncmVlbicsXG4gICAgJ2N5YW4nLFxuICAgICdyZWQnLFxuICAgICdtYWdlbnRhJyxcbiAgICAnYnJvd24nLFxuICAgICdsaWdodC1ncmF5JyxcbiAgICAnZGFyay1ncmF5JyxcbiAgICAnbGlnaHQtYmx1ZScsXG4gICAgJ2xpZ2h0LWdyZWVuJyxcbiAgICAnbGlnaHQtY3lhbicsXG4gICAgJ2xpZ2h0LXJlZCcsXG4gICAgJ2xpZ2h0LW1hZ2VudGEnLFxuICAgICd5ZWxsb3cnLFxuICAgICd3aGl0ZSdcbl07XG4iLCJleHBvcnQgY29uc3Qgc2V0Q2FjaGVJdGVtQXNCbG9iID0gKHsgY2FjaGVJZCwgcmVxdWVzdFVSTCwgcmVzcG9uc2VEYXRhIH0pID0+IHtcbiAgICBjb25zdCByZXNwb25zZSA9IG5ldyBSZXNwb25zZShyZXNwb25zZURhdGEpO1xuICAgIGNhY2hlcy5vcGVuKGNhY2hlSWQpLnRoZW4oY2FjaGUgPT4gY2FjaGUucHV0KHJlcXVlc3RVUkwsIHJlc3BvbnNlKSk7XG59O1xuXG5leHBvcnQgY29uc3QgZ2V0Q2FjaGVJdGVtQXNBcnJheUJ1ZmZlciA9IGFzeW5jICh7IGNhY2hlSWQsIHJlcXVlc3RVUkwgfSkgPT4ge1xuICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IGNhY2hlID0gYXdhaXQgY2FjaGVzLm9wZW4oY2FjaGVJZCk7XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgY2FjaGUubWF0Y2gocmVxdWVzdFVSTCk7XG5cbiAgICAgICAgaWYgKCFyZXNwb25zZSkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gYXdhaXQgcmVzcG9uc2UuYXJyYXlCdWZmZXIoKTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgYEFuIGVycm9yIG9jY3VycmVkIHdoaWxlIHJldHJpZXZpbmcgY2FjaGUgb2YgJyR7cmVxdWVzdFVSTH0nLmAsXG4gICAgICAgICAgICB7IGVycm9yIH1cbiAgICAgICAgKTtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxufTtcblxuZXhwb3J0IGNvbnN0IGdldENhY2hlSXRlbUFzQmxvYiA9IGFzeW5jICh7IGNhY2hlSWQsIHJlcXVlc3RVUkwgfSkgPT4ge1xuICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IGNhY2hlID0gYXdhaXQgY2FjaGVzLm9wZW4oY2FjaGVJZCk7XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgY2FjaGUubWF0Y2gocmVxdWVzdFVSTCk7XG5cbiAgICAgICAgaWYgKCFyZXNwb25zZSkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gYXdhaXQgcmVzcG9uc2UuYmxvYigpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICBgQW4gZXJyb3Igb2NjdXJyZWQgd2hpbGUgcmV0cmlldmluZyBjYWNoZSBvZiAnJHtyZXF1ZXN0VVJMfScuYCxcbiAgICAgICAgICAgIHsgZXJyb3IgfVxuICAgICAgICApO1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG59O1xuXG5leHBvcnQgY29uc3QgZ2V0Q2FjaGVJdGVtQXNKc29uID0gYXN5bmMgKHsgY2FjaGVJZCwgcmVxdWVzdFVSTCB9KSA9PiB7XG4gICAgdHJ5IHtcbiAgICAgICAgY29uc3QgY2FjaGUgPSBhd2FpdCBjYWNoZXMub3BlbihjYWNoZUlkKTtcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBjYWNoZS5tYXRjaChyZXF1ZXN0VVJMKTtcblxuICAgICAgICBpZiAoIXJlc3BvbnNlKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBhd2FpdCByZXNwb25zZS5qc29uKCk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgIGBBbiBlcnJvciBvY2N1cnJlZCB3aGlsZSByZXRyaWV2aW5nIGNhY2hlIG9mICcke3JlcXVlc3RVUkx9Jy5gLFxuICAgICAgICAgICAgeyBlcnJvciB9XG4gICAgICAgICk7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbn07XG5cbmV4cG9ydCBjb25zdCBnZXRDYWNoZUl0ZW1Bc1RleHQgPSBhc3luYyAoeyBjYWNoZUlkLCByZXF1ZXN0VVJMIH0pID0+IHtcbiAgICB0cnkge1xuICAgICAgICBjb25zdCBjYWNoZSA9IGF3YWl0IGNhY2hlcy5vcGVuKGNhY2hlSWQpO1xuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGNhY2hlLm1hdGNoKHJlcXVlc3RVUkwpO1xuXG4gICAgICAgIGlmICghcmVzcG9uc2UpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGF3YWl0IHJlc3BvbnNlLnRleHQoKTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgYEFuIGVycm9yIG9jY3VycmVkIHdoaWxlIHJldHJpZXZpbmcgY2FjaGUgb2YgJyR7cmVxdWVzdFVSTH0nLmAsXG4gICAgICAgICAgICB7IGVycm9yIH1cbiAgICAgICAgKTtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxufTtcblxuZXhwb3J0IGNvbnN0IGRlbGV0ZUNhY2hlID0gYXN5bmMgKHsgY2FjaGVJZCB9KSA9PiB7XG4gICAgdHJ5IHtcbiAgICAgICAgYXdhaXQgY2FjaGVzLmRlbGV0ZShjYWNoZUlkKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgIGBBbiBlcnJvciBvY2N1cnJlZCB3aGlsZSBkZWxldGluZyBjYWNoZSBvZiAnJHtjYWNoZUlkfScuYCxcbiAgICAgICAgICAgIHsgZXJyb3IgfVxuICAgICAgICApO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxufTtcblxuZXhwb3J0IGNvbnN0IGRlbGV0ZUFsbENhY2hlID0gYXN5bmMgKCkgPT4ge1xuICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IGNhY2hlS2V5cyA9IGF3YWl0IGNhY2hlcy5rZXlzKCk7XG4gICAgICAgIGF3YWl0IGNhY2hlS2V5cy5tYXAoYXN5bmMga2V5ID0+IHtcbiAgICAgICAgICAgIGF3YWl0IGNhY2hlcy5kZWxldGUoa2V5KTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ0FuIGVycm9yIG9jY3VycmVkIHdoaWxlIGRlbGV0aW5nIHRoZSBjYWNoZS4nLCB7IGVycm9yIH0pO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxufTtcbiIsImltcG9ydCB7XG4gICAgTUlESV9IRUFERVJfREFUQSxcbiAgICBNVVNfSEVBREVSX1NJR05BVFVSRSxcbiAgICBNVVNfTlVNX0NIQU5ORUxTLFxuICAgIE1VU19QRVJDVVNTSU9OX0NIQU5ORUwsXG4gICAgTUlESV9QRVJDVVNTSU9OX0NIQU5ORUwsXG4gICAgTUlESV9UUkFDS0xFTkdUSF9PRlMsXG4gICAgTUlESV9DT05UUk9MTEVSX01BUCxcbiAgICBNVVNfUkVMRUFTRV9LRVksXG4gICAgTVVTX1BSRVNTX0tFWSxcbiAgICBNVVNfUElUQ0hfV0hFRUwsXG4gICAgTVVTX1NZU1RFTV9FVkVOVCxcbiAgICBNVVNfQ0hBTkdFX0NPTlRST0xMRVIsXG4gICAgTVVTX1NDT1JFX0VORCxcbiAgICBNSURJX1JFTEVBU0VfS0VZLFxuICAgIE1JRElfUFJFU1NfS0VZLFxuICAgIE1JRElfQ0hBTkdFX0NPTlRST0xMRVIsXG4gICAgTUlESV9DSEFOR0VfUEFUQ0gsXG4gICAgTUlESV9QSVRDSF9XSEVFTFxufSBmcm9tICcuLi9saWIvY29uc3RhbnRzJztcblxuaW1wb3J0IHtcbiAgICBnZXRDYWNoZUl0ZW1Bc0FycmF5QnVmZmVyLFxuICAgIHNldENhY2hlSXRlbUFzQmxvYlxufSBmcm9tICcuLi9saWIvY2FjaGVNYW5hZ2VyJztcblxuZnVuY3Rpb24gcmVhZE11c0hlYWRlcihkYXRhVmlldykge1xuICAgIGNvbnN0IGlkID0gW107XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IDQ7IGkrKykge1xuICAgICAgICBpZC5wdXNoKGRhdGFWaWV3LmdldFVpbnQ4KGkpKTtcbiAgICB9XG5cbiAgICBjb25zdCBtdXNIZWFkZXIgPSB7XG4gICAgICAgIC8vIHVzZWQgdG8gY2hlY2sgdGhhdCB0aGlzIGlzIGEgdmFsaWQgTVVTIGZpbGVcbiAgICAgICAgaWQ6IGlkLmpvaW4oJyAnKSxcbiAgICAgICAgc2NvcmVMZW5ndGg6IGRhdGFWaWV3LmdldFVpbnQxNig0LCB0cnVlKSxcbiAgICAgICAgLy8gb25seSB0aGlzIHZhbHVlIGlzIHRydWx5IGhlbHBmdWwgdG8gcGFyc2UgdGhlIE1VU1xuICAgICAgICBzY29yZVN0YXJ0OiBkYXRhVmlldy5nZXRVaW50MTYoNiwgdHJ1ZSksXG4gICAgICAgIHByaW1hcnlDaGFubmVsczogZGF0YVZpZXcuZ2V0VWludDE2KDgsIHRydWUpLFxuICAgICAgICBzZWNvbmRhcnlDaGFubmVsczogZGF0YVZpZXcuZ2V0VWludDE2KDEwLCB0cnVlKSxcbiAgICAgICAgaW5zdHJ1bWVudENvdW50OiBkYXRhVmlldy5nZXRVaW50MTYoMTIsIHRydWUpXG4gICAgfTtcblxuICAgIHJldHVybiBtdXNIZWFkZXI7XG59XG5cbmZ1bmN0aW9uIGlzVmFsaWRNdXNIZWFkZXIoaWQpIHtcbiAgICByZXR1cm4gTVVTX0hFQURFUl9TSUdOQVRVUkUgPT09IGlkO1xufVxuXG4vLyBUT0RPOiBTZW5kIHRoZSBlcnJvciBzdHJpbmcgaW4gcG9zdE1lc3NhZ2Vcblxub25tZXNzYWdlID0gYXN5bmMgbWVzc2FnZSA9PiB7XG4gICAgdHJ5IHtcbiAgICAgICAgY29uc3QgeyB3YWRJZCwgbHVtcCB9ID0gbWVzc2FnZS5kYXRhO1xuXG4gICAgICAgIGNvbnN0IHsgbmFtZSwgdHlwZSwgZGF0YSwgb3JpZ2luYWxGb3JtYXQgfSA9IGx1bXA7XG5cbiAgICAgICAgY29uc3QgcmVxdWVzdFVSTCA9IGAvbWlkaXMvJHt3YWRJZH0vJHtuYW1lfWA7XG5cbiAgICAgICAgaWYgKG9yaWdpbmFsRm9ybWF0ID09PSAnTUlESScpIHtcbiAgICAgICAgICAgIHNldENhY2hlSXRlbUFzQmxvYih7XG4gICAgICAgICAgICAgICAgY2FjaGVJZDogd2FkSWQsXG4gICAgICAgICAgICAgICAgcmVxdWVzdFVSTCxcbiAgICAgICAgICAgICAgICByZXNwb25zZURhdGE6IGRhdGFcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBwb3N0TWVzc2FnZSh7XG4gICAgICAgICAgICAgICAgd2FkSWQsXG4gICAgICAgICAgICAgICAgbHVtcElkOiBuYW1lLFxuICAgICAgICAgICAgICAgIGx1bXBUeXBlOiB0eXBlLFxuICAgICAgICAgICAgICAgIG91dHB1dDogcmVxdWVzdFVSTFxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGNhY2hlZEl0ZW0gPSBhd2FpdCBnZXRDYWNoZUl0ZW1Bc0FycmF5QnVmZmVyKHtcbiAgICAgICAgICAgIGNhY2hlSWQ6IHdhZElkLFxuICAgICAgICAgICAgcmVxdWVzdFVSTFxuICAgICAgICB9KTtcblxuICAgICAgICBpZiAoY2FjaGVkSXRlbSkge1xuICAgICAgICAgICAgcG9zdE1lc3NhZ2Uoe1xuICAgICAgICAgICAgICAgIHdhZElkLFxuICAgICAgICAgICAgICAgIGx1bXBJZDogbmFtZSxcbiAgICAgICAgICAgICAgICBsdW1wVHlwZTogdHlwZSxcbiAgICAgICAgICAgICAgICBvdXRwdXQ6IHJlcXVlc3RVUkxcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAvLyBjb25zb2xlLmxvZyhgQ29udmVydGluZyAnJHt0eXBlfS8ke25hbWV9JyBmcm9tIE1VUyB0byBNSURJIChXQUQ6ICcke3dhZElkfScpIC4uLmApO1xuXG4gICAgICAgIGxldCBtdXNEYXRhVmlldztcbiAgICAgICAgbGV0IG11c0RhdGFQb3NpdGlvbjtcblxuICAgICAgICAvLyBDYWNoZWQgY2hhbm5lbCB2ZWxvY2l0aWVzXG4gICAgICAgIGNvbnN0IGNoYW5uZWx2ZWxvY2l0aWVzID0gW1xuICAgICAgICAgICAgMTI3LFxuICAgICAgICAgICAgMTI3LFxuICAgICAgICAgICAgMTI3LFxuICAgICAgICAgICAgMTI3LFxuICAgICAgICAgICAgMTI3LFxuICAgICAgICAgICAgMTI3LFxuICAgICAgICAgICAgMTI3LFxuICAgICAgICAgICAgMTI3LFxuICAgICAgICAgICAgMTI3LFxuICAgICAgICAgICAgMTI3LFxuICAgICAgICAgICAgMTI3LFxuICAgICAgICAgICAgMTI3LFxuICAgICAgICAgICAgMTI3LFxuICAgICAgICAgICAgMTI3LFxuICAgICAgICAgICAgMTI3LFxuICAgICAgICAgICAgMTI3XG4gICAgICAgIF07XG5cbiAgICAgICAgLy8gVGltZXN0YW1wcyBiZXR3ZWVuIHNlcXVlbmNlcyBvZiBNVVMgZXZlbnRzXG4gICAgICAgIGxldCBxdWV1ZWR0aW1lID0gMDtcblxuICAgICAgICAvLyBDb3VudGVyIGZvciB0aGUgbGVuZ3RoIG9mIHRoZSB0cmFja1xuICAgICAgICBsZXQgdHJhY2tzaXplO1xuXG4gICAgICAgIGNvbnN0IGNoYW5uZWxNYXAgPSBbXTtcblxuICAgICAgICAvLyBNYWluIERhdGFWaWV3IGZvciB3cml0aW5nIHRvLiBUaGlzIGlzIHVzZWQgYnkgd3JpdGVEYXRhKCk7XG4gICAgICAgIGxldCBvdXRwdXREYXRhVmlldztcblxuICAgICAgICAvLyBXcmFwcGVyIGZ1bmN0aW9uIHRvIHdvcmsgbGlrZSBzbGFkZSdzIG1lbWNodW5rLndyaXRlKClcbiAgICAgICAgLy8gSSdtIHNvIGxhenlcbiAgICAgICAgbGV0IHBvc2l0aW9uID0gMDtcbiAgICAgICAgbGV0IGRhdGFUb1dyaXRlID0gW107XG4gICAgICAgIGZ1bmN0aW9uIHdyaXRlRGF0YShieXRlcykge1xuICAgICAgICAgICAgZGF0YVRvV3JpdGUgPSBkYXRhVG9Xcml0ZS5jb25jYXQoYnl0ZXMpO1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gY29uZmlybVdyaXRlKCkge1xuICAgICAgICAgICAgY29uc3QgbmV3QnVmZmVyID0gbmV3IEFycmF5QnVmZmVyKGRhdGFUb1dyaXRlLmxlbmd0aCk7XG4gICAgICAgICAgICBvdXRwdXREYXRhVmlldyA9IG5ldyBEYXRhVmlldyhuZXdCdWZmZXIpO1xuICAgICAgICAgICAgLy8gVGhlbiB3cml0ZSB0aGUgZGF0YVxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBkYXRhVG9Xcml0ZS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIG91dHB1dERhdGFWaWV3LnNldFVpbnQ4KHBvc2l0aW9uLCBkYXRhVG9Xcml0ZVtpXSk7XG4gICAgICAgICAgICAgICAgcG9zaXRpb24gKz0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFdyaXRlIHRpbWVzdGFtcCB0byBhIE1JREkgZmlsZS5cbiAgICAgICAgZnVuY3Rpb24gd3JpdGVUaW1lKHRpbWUpIHtcbiAgICAgICAgICAgIGxldCBidWZmZXIgPSB0aW1lICYgMHg3ZjtcbiAgICAgICAgICAgIGxldCB3cml0ZXZhbDtcblxuICAgICAgICAgICAgd2hpbGUgKCh0aW1lID4+PSA3KSAhPSAwKSB7XG4gICAgICAgICAgICAgICAgYnVmZmVyIDw8PSA4O1xuICAgICAgICAgICAgICAgIGJ1ZmZlciB8PSAodGltZSAmIDB4N2YpIHwgMHg4MDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZm9yICg7Oykge1xuICAgICAgICAgICAgICAgIHdyaXRldmFsID0gYnVmZmVyICYgMHhmZjtcblxuICAgICAgICAgICAgICAgIHdyaXRlRGF0YShbd3JpdGV2YWxdKTtcblxuICAgICAgICAgICAgICAgIHRyYWNrc2l6ZSArPSAxO1xuXG4gICAgICAgICAgICAgICAgaWYgKChidWZmZXIgJiAweDgwKSAhPSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGJ1ZmZlciA+Pj0gODtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBxdWV1ZWR0aW1lID0gMDtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFdyaXRlIHRoZSBlbmQgb2YgdHJhY2sgbWFya2VyXG4gICAgICAgIGZ1bmN0aW9uIHdyaXRlRW5kVHJhY2soKSB7XG4gICAgICAgICAgICBjb25zdCBlbmR0cmFjayA9IFsweGZmLCAweDJmLCAweDAwXTtcblxuICAgICAgICAgICAgd3JpdGVUaW1lKHF1ZXVlZHRpbWUpO1xuXG4gICAgICAgICAgICB3cml0ZURhdGEoZW5kdHJhY2spO1xuXG4gICAgICAgICAgICB0cmFja3NpemUgKz0gMztcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFdyaXRlIGEga2V5IHByZXNzIGV2ZW50XG4gICAgICAgIGZ1bmN0aW9uIHdyaXRlUHJlc3NLZXkoY2hhbm5lbCwga2V5LCB2ZWxvY2l0eSkge1xuICAgICAgICAgICAgLy8gV3JpdGUgcXVldWVkIHRpbWVcbiAgICAgICAgICAgIHdyaXRlVGltZShxdWV1ZWR0aW1lKTtcblxuICAgICAgICAgICAgLy8gV3JpdGUgcHJlc3NlZCBrZXkgYW5kIGNoYW5uZWxcbiAgICAgICAgICAgIGxldCB3b3JraW5nID0gTUlESV9QUkVTU19LRVkgfCBjaGFubmVsO1xuICAgICAgICAgICAgd3JpdGVEYXRhKFt3b3JraW5nXSk7XG5cbiAgICAgICAgICAgIC8vIFdyaXRlIGtleVxuICAgICAgICAgICAgd29ya2luZyA9IGtleSAmIDB4N2Y7XG4gICAgICAgICAgICB3cml0ZURhdGEoW3dvcmtpbmddKTtcblxuICAgICAgICAgICAgLy8gV2l0ZSB2ZWxvY2l0eVxuICAgICAgICAgICAgd29ya2luZyA9IHZlbG9jaXR5ICYgMHg3ZjtcbiAgICAgICAgICAgIHdyaXRlRGF0YShbd29ya2luZ10pO1xuXG4gICAgICAgICAgICB0cmFja3NpemUgKz0gMztcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFdyaXRlIGEga2V5IHJlbGVhc2UgZXZlbnRcbiAgICAgICAgZnVuY3Rpb24gd3JpdGVSZWxlYXNlS2V5KGNoYW5uZWwsIGtleSkge1xuICAgICAgICAgICAgLy8gV3JpdGUgcXVldWVkIHRpbWVcbiAgICAgICAgICAgIHdyaXRlVGltZShxdWV1ZWR0aW1lKTtcblxuICAgICAgICAgICAgLy8gV3JpdGUgcmVsZWFzZWQga2V5XG4gICAgICAgICAgICBsZXQgd29ya2luZyA9IE1JRElfUkVMRUFTRV9LRVkgfCBjaGFubmVsO1xuICAgICAgICAgICAgd3JpdGVEYXRhKFt3b3JraW5nXSk7XG5cbiAgICAgICAgICAgIC8vIFdyaXRlIGtleVxuICAgICAgICAgICAgd29ya2luZyA9IGtleSAmIDB4N2Y7XG4gICAgICAgICAgICB3cml0ZURhdGEoW3dvcmtpbmddKTtcblxuICAgICAgICAgICAgLy8gRHVtbXlcbiAgICAgICAgICAgIHdvcmtpbmcgPSAwO1xuICAgICAgICAgICAgd3JpdGVEYXRhKFt3b3JraW5nXSk7XG5cbiAgICAgICAgICAgIHRyYWNrc2l6ZSArPSAzO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gV3JpdGUgYSBwaXRjaCB3aGVlbC9iZW5kIGV2ZW50XG4gICAgICAgIGZ1bmN0aW9uIHdyaXRlUGl0Y2hXaGVlbChjaGFubmVsLCB3aGVlbCkge1xuICAgICAgICAgICAgLy8gV3JpdGUgcXVldWVkIHRpbWVcbiAgICAgICAgICAgIHdyaXRlVGltZShxdWV1ZWR0aW1lKTtcblxuICAgICAgICAgICAgbGV0IHdvcmtpbmcgPSBNSURJX1BJVENIX1dIRUVMIHwgY2hhbm5lbDtcbiAgICAgICAgICAgIHdyaXRlRGF0YShbd29ya2luZ10pO1xuXG4gICAgICAgICAgICB3b3JraW5nID0gd2hlZWwgJiAweDdmO1xuICAgICAgICAgICAgd3JpdGVEYXRhKFt3b3JraW5nXSk7XG5cbiAgICAgICAgICAgIHdvcmtpbmcgPSAod2hlZWwgPj4gNykgJiAweDdmO1xuICAgICAgICAgICAgd3JpdGVEYXRhKFt3b3JraW5nXSk7XG5cbiAgICAgICAgICAgIHRyYWNrc2l6ZSArPSAzO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gV3JpdGUgYSBwYXRjaCBjaGFuZ2UgZXZlbnRcbiAgICAgICAgZnVuY3Rpb24gd3JpdGVDaGFuZ2VQYXRjaChjaGFubmVsLCBwYXRjaCkge1xuICAgICAgICAgICAgLy8gV3JpdGUgcXVldWVkIHRpbWVcbiAgICAgICAgICAgIHdyaXRlVGltZShxdWV1ZWR0aW1lKTtcblxuICAgICAgICAgICAgbGV0IHdvcmtpbmcgPSBNSURJX0NIQU5HRV9QQVRDSCB8IGNoYW5uZWw7XG4gICAgICAgICAgICB3cml0ZURhdGEoW3dvcmtpbmddKTtcblxuICAgICAgICAgICAgd29ya2luZyA9IHBhdGNoICYgMHg3ZjtcbiAgICAgICAgICAgIHdyaXRlRGF0YShbd29ya2luZ10pO1xuXG4gICAgICAgICAgICB0cmFja3NpemUgKz0gMjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFdyaXRlIGEgdmFsdWVkIGNvbnRyb2xsZXIgY2hhbmdlIGV2ZW50XG4gICAgICAgIGZ1bmN0aW9uIHdyaXRlQ2hhbmdlQ29udHJvbGxlclZhbHVlZChjaGFubmVsLCBjb250cm9sLCB2YWx1ZSkge1xuICAgICAgICAgICAgLy8gV3JpdGUgcXVldWVkIHRpbWVcbiAgICAgICAgICAgIHdyaXRlVGltZShxdWV1ZWR0aW1lKTtcblxuICAgICAgICAgICAgbGV0IHdvcmtpbmcgPSBNSURJX0NIQU5HRV9DT05UUk9MTEVSIHwgY2hhbm5lbDtcbiAgICAgICAgICAgIHdyaXRlRGF0YShbd29ya2luZ10pO1xuXG4gICAgICAgICAgICB3b3JraW5nID0gY29udHJvbCAmIDB4N2Y7XG4gICAgICAgICAgICB3cml0ZURhdGEoW3dvcmtpbmddKTtcblxuICAgICAgICAgICAgLy8gUXVpcmsgaW4gdmFuaWxsYSBET09NPyBNVVMgY29udHJvbGxlciB2YWx1ZXMgc2hvdWxkIGJlIDctYml0LCBub3QgOC1iaXQuXG4gICAgICAgICAgICB3b3JraW5nID0gdmFsdWUgJiAweDgwID8gMHg3ZiA6IHZhbHVlO1xuICAgICAgICAgICAgd3JpdGVEYXRhKFt3b3JraW5nXSk7XG5cbiAgICAgICAgICAgIHRyYWNrc2l6ZSArPSAzO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gV3JpdGUgYSB2YWx1ZWxlc3MgY29udHJvbGxlciBjaGFuZ2UgZXZlbnRcbiAgICAgICAgZnVuY3Rpb24gd3JpdGVDaGFuZ2VDb250cm9sbGVyVmFsdWVsZXNzKGNoYW5uZWwsIGNvbnRyb2wpIHtcbiAgICAgICAgICAgIHdyaXRlQ2hhbmdlQ29udHJvbGxlclZhbHVlZChjaGFubmVsLCBjb250cm9sLCAwKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEFsbG9jYXRlIGEgZnJlZSBNSURJIGNoYW5uZWwuXG4gICAgICAgIGZ1bmN0aW9uIGFsbG9jYXRlTUlESUNoYW5uZWwoKSB7XG4gICAgICAgICAgICBsZXQgcmVzdWx0O1xuICAgICAgICAgICAgbGV0IG1heDtcbiAgICAgICAgICAgIGxldCBpO1xuXG4gICAgICAgICAgICAvLyBGaW5kIHRoZSBjdXJyZW50IGhpZ2hlc3QtYWxsb2NhdGVkIGNoYW5uZWwuXG5cbiAgICAgICAgICAgIG1heCA9IC0xO1xuXG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgTVVTX05VTV9DSEFOTkVMUzsgKytpKSB7XG4gICAgICAgICAgICAgICAgaWYgKGNoYW5uZWxNYXBbaV0gPiBtYXgpIHtcbiAgICAgICAgICAgICAgICAgICAgbWF4ID0gY2hhbm5lbE1hcFtpXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIG1heCBpcyBub3cgZXF1YWwgdG8gdGhlIGhpZ2hlc3QtYWxsb2NhdGVkIE1JREkgY2hhbm5lbC4gIFdlIGNhblxuICAgICAgICAgICAgLy8gbm93IGFsbG9jYXRlIHRoZSBuZXh0IGF2YWlsYWJsZSBjaGFubmVsLiAgVGhpcyBhbHNvIHdvcmtzIGlmXG4gICAgICAgICAgICAvLyBubyBjaGFubmVscyBhcmUgY3VycmVudGx5IGFsbG9jYXRlZCAobWF4PS0xKVxuXG4gICAgICAgICAgICByZXN1bHQgPSBtYXggKyAxO1xuXG4gICAgICAgICAgICAvLyBEb24ndCBhbGxvY2F0ZSB0aGUgTUlESSBwZXJjdXNzaW9uIGNoYW5uZWwhXG5cbiAgICAgICAgICAgIGlmIChyZXN1bHQgPT09IE1JRElfUEVSQ1VTU0lPTl9DSEFOTkVMKSB7XG4gICAgICAgICAgICAgICAgKytyZXN1bHQ7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBHaXZlbiBhIE1VUyBjaGFubmVsIG51bWJlciwgZ2V0IHRoZSBNSURJIGNoYW5uZWwgbnVtYmVyIHRvIHVzZSBpbiB0aGUgb3V0cHV0dGVkIGZpbGUuXG4gICAgICAgIGZ1bmN0aW9uIGdldE1JRElDaGFubmVsKG11c0NoYW5uZWwpIHtcbiAgICAgICAgICAgIC8vIEZpbmQgdGhlIE1JREkgY2hhbm5lbCB0byB1c2UgZm9yIHRoaXMgTVVTIGNoYW5uZWwuXG4gICAgICAgICAgICAvLyBNVVMgY2hhbm5lbCAxNSBpcyB0aGUgcGVyY3Vzc3Npb24gY2hhbm5lbC5cblxuICAgICAgICAgICAgaWYgKG11c0NoYW5uZWwgPT09IE1VU19QRVJDVVNTSU9OX0NIQU5ORUwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gTUlESV9QRVJDVVNTSU9OX0NIQU5ORUw7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIElmIGEgTUlESSBjaGFubmVsIGhhc24ndCBiZWVuIGFsbG9jYXRlZCBmb3IgdGhpcyBNVVMgY2hhbm5lbFxuICAgICAgICAgICAgLy8geWV0LCBhbGxvY2F0ZSB0aGUgbmV4dCBmcmVlIE1JREkgY2hhbm5lbC5cblxuICAgICAgICAgICAgaWYgKGNoYW5uZWxNYXBbbXVzQ2hhbm5lbF0gPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgY2hhbm5lbE1hcFttdXNDaGFubmVsXSA9IGFsbG9jYXRlTUlESUNoYW5uZWwoKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIGNoYW5uZWxNYXBbbXVzQ2hhbm5lbF07XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBjb252ZXJ0TXVzVG9NaWRpKG11c2lucHV0KSB7XG4gICAgICAgICAgICAvLyBtYXN0ZXIgZGF0YXZpZXcgZm9yIGlucHV0IG11c1xuICAgICAgICAgICAgbXVzRGF0YVZpZXcgPSBtdXNpbnB1dDtcbiAgICAgICAgICAgIG11c0RhdGFQb3NpdGlvbiA9IDA7XG5cbiAgICAgICAgICAgIGZ1bmN0aW9uIGdldE11c0J5dGU4KCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IG91dHB1dCA9IG11c0RhdGFWaWV3LmdldFVpbnQ4KG11c0RhdGFQb3NpdGlvbik7XG4gICAgICAgICAgICAgICAgbXVzRGF0YVBvc2l0aW9uICs9IDE7XG4gICAgICAgICAgICAgICAgLy8gY29uc29sZS5sb2cob3V0cHV0KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gb3V0cHV0O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBtYXN0ZXIgZGF0YSBmb3Igb3V0cHV0IG1pZGlcbiAgICAgICAgICAgIGNvbnN0IG91dHB1dEFycmF5QnVmZmVyID0gbmV3IEFycmF5QnVmZmVyKDApO1xuICAgICAgICAgICAgb3V0cHV0RGF0YVZpZXcgPSBuZXcgRGF0YVZpZXcob3V0cHV0QXJyYXlCdWZmZXIpO1xuXG4gICAgICAgICAgICAvLyBEZXNjcmlwdG9yIGZvciB0aGUgY3VycmVudCBNVVMgZXZlbnRcbiAgICAgICAgICAgIGxldCBldmVudGRlc2NyaXB0b3I7XG4gICAgICAgICAgICBsZXQgY2hhbm5lbDsgLy8gQ2hhbm5lbCBudW1iZXJcbiAgICAgICAgICAgIGxldCBtdXNFdmVudDtcblxuICAgICAgICAgICAgLy8gQnVuY2ggb2YgdmFycyByZWFkIGZyb20gTVVTIGx1bXBcbiAgICAgICAgICAgIGxldCBrZXk7XG4gICAgICAgICAgICBsZXQgY29udHJvbGxlcm51bWJlcjtcbiAgICAgICAgICAgIGxldCBjb250cm9sbGVydmFsdWU7XG5cbiAgICAgICAgICAgIC8vIEZsYWcgZm9yIHdoZW4gdGhlIHNjb3JlIGVuZCBtYXJrZXIgaXMgaGl0LlxuICAgICAgICAgICAgbGV0IGhpdFNjb3JlRW5kID0gZmFsc2U7XG5cbiAgICAgICAgICAgIC8vIFRlbXAgd29ya2luZyBieXRlXG4gICAgICAgICAgICBsZXQgd29ya2luZztcbiAgICAgICAgICAgIC8vIFVzZWQgaW4gYnVpbGRpbmcgdXAgdGltZSBkZWxheXNcbiAgICAgICAgICAgIGxldCB0aW1lZGVsYXk7XG5cbiAgICAgICAgICAgIC8vIEluaXRpYWxpc2UgY2hhbm5lbCBtYXAgdG8gbWFyayBhbGwgY2hhbm5lbHMgYXMgdW51c2VkLlxuICAgICAgICAgICAgZm9yIChjaGFubmVsID0gMDsgY2hhbm5lbCA8IE1VU19OVU1fQ0hBTk5FTFM7ICsrY2hhbm5lbCkge1xuICAgICAgICAgICAgICAgIGNoYW5uZWxNYXBbY2hhbm5lbF0gPSAtMTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY29uc3QgbXVzSGVhZGVyID0gcmVhZE11c0hlYWRlcihtdXNEYXRhVmlldyk7XG5cbiAgICAgICAgICAgIGlmICghaXNWYWxpZE11c0hlYWRlcihtdXNIZWFkZXIuaWQpKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICAgICAgICAgYEludmFsaWQgTVVTIGhlYWRlcjogJyR7XG4gICAgICAgICAgICAgICAgICAgICAgICBtdXNIZWFkZXIuaWRcbiAgICAgICAgICAgICAgICAgICAgfScuIEV4cGVjdGVkOiAnJHtNVVNfSEVBREVSX1NJR05BVFVSRX0nYFxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBTZWVrIHRvIHdoZXJlIHRoZSBkYXRhIGlzIGhlbGRcbiAgICAgICAgICAgIG11c0RhdGFQb3NpdGlvbiA9IG11c0hlYWRlci5zY29yZVN0YXJ0O1xuICAgICAgICAgICAgLy8gU28sIHdlIGNhbiBhc3N1bWUgdGhlIE1VUyBmaWxlIGlzIGZhaW50bHkgbGVnaXQuIExldCdzIHN0YXJ0IHdyaXRpbmcgTUlESSBkYXRhLi4uXG5cbiAgICAgICAgICAgIHdyaXRlRGF0YShNSURJX0hFQURFUl9EQVRBKTtcbiAgICAgICAgICAgIHRyYWNrc2l6ZSA9IDA7XG5cbiAgICAgICAgICAgIC8vIE5vdywgcHJvY2VzcyB0aGUgTVVTIGZpbGU6XG4gICAgICAgICAgICB3aGlsZSAoIWhpdFNjb3JlRW5kKSB7XG4gICAgICAgICAgICAgICAgLy8gSGFuZGxlIGEgYmxvY2sgb2YgZXZlbnRzOlxuXG4gICAgICAgICAgICAgICAgd2hpbGUgKCFoaXRTY29yZUVuZCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBGZXRjaCBjaGFubmVsIG51bWJlciBhbmQgZXZlbnQgY29kZTpcbiAgICAgICAgICAgICAgICAgICAgZXZlbnRkZXNjcmlwdG9yID0gZ2V0TXVzQnl0ZTgoKTtcblxuICAgICAgICAgICAgICAgICAgICBjaGFubmVsID0gZ2V0TUlESUNoYW5uZWwoZXZlbnRkZXNjcmlwdG9yICYgMHgwZik7XG4gICAgICAgICAgICAgICAgICAgIG11c0V2ZW50ID0gZXZlbnRkZXNjcmlwdG9yICYgMHg3MDtcbiAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChtdXNFdmVudCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBNVVNfUkVMRUFTRV9LRVk6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gY29uc29sZS5sb2coJ01VU19SRUxFQVNFX0tFWScpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGtleSA9IGdldE11c0J5dGU4KCk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB3cml0ZVJlbGVhc2VLZXkoY2hhbm5lbCwga2V5KTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIE1VU19QUkVTU19LRVk6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAga2V5ID0gZ2V0TXVzQnl0ZTgoKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChrZXkgJiAweDgwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNoYW5uZWx2ZWxvY2l0aWVzW2NoYW5uZWxdID0gZ2V0TXVzQnl0ZTgoKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjaGFubmVsdmVsb2NpdGllc1tjaGFubmVsXSAmPSAweDdmO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKCdNVVNfUFJFU1NfS0VZOiAnK2tleSsgJyAnICsgY2hhbm5lbHZlbG9jaXRpZXNbY2hhbm5lbF0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKCdNVVNfUFJFU1NfS0VZOiAnK2tleSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgd3JpdGVQcmVzc0tleShcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2hhbm5lbCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAga2V5LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjaGFubmVsdmVsb2NpdGllc1tjaGFubmVsXVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBNVVNfUElUQ0hfV0hFRUw6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gY29uc29sZS5sb2coJ01VU19QSVRDSF9XSEVFTCcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGtleSA9IGdldE11c0J5dGU4KCk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB3cml0ZVBpdGNoV2hlZWwoY2hhbm5lbCwga2V5ICogNjQpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgTVVTX1NZU1RFTV9FVkVOVDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBjb25zb2xlLmxvZygnTVVTX1NZU1RFTV9FVkVOVCcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRyb2xsZXJudW1iZXIgPSBnZXRNdXNCeXRlOCgpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250cm9sbGVybnVtYmVyIDwgMTAgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udHJvbGxlcm51bWJlciA+IDE0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBgQ29udHJvbGxlciBudW1iZXIgaW5hY2N1cmF0ZSAxMC0xNDogJHtjb250cm9sbGVybnVtYmVyfWBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdyaXRlQ2hhbmdlQ29udHJvbGxlclZhbHVlbGVzcyhcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2hhbm5lbCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgTUlESV9DT05UUk9MTEVSX01BUFtjb250cm9sbGVybnVtYmVyXVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBNVVNfQ0hBTkdFX0NPTlRST0xMRVI6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udHJvbGxlcm51bWJlciA9IGdldE11c0J5dGU4KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udHJvbGxlcnZhbHVlID0gZ2V0TXVzQnl0ZTgoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBjb25zb2xlLmxvZygnTVVTX0NIQU5HRV9DT05UUk9MTEVSOiAnICtjb250cm9sbGVybnVtYmVyKycgJytjb250cm9sbGVydmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjb250cm9sbGVybnVtYmVyID09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd3JpdGVDaGFuZ2VQYXRjaChjaGFubmVsLCBjb250cm9sbGVydmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRyb2xsZXJudW1iZXIgPCAxIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250cm9sbGVybnVtYmVyID4gOVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYENvbnRyb2xsZXIgbnVtYmVyIGluYWNjdXJhdGU6ICR7Y29udHJvbGxlcm51bWJlcn1gXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd3JpdGVDaGFuZ2VDb250cm9sbGVyVmFsdWVkKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2hhbm5lbCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE1JRElfQ09OVFJPTExFUl9NQVBbY29udHJvbGxlcm51bWJlcl0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250cm9sbGVydmFsdWVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBNVVNfU0NPUkVfRU5EOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKCdtdXNTY29yZUVuZCcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhpdFNjb3JlRW5kID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBjb25zb2xlLmxvZygnZXZlbnRkZXNjcmlwdG9yIGRlZmF1bHQ6ICcrZXZlbnRkZXNjcmlwdG9yICsgJyAnICsgKGV2ZW50ZGVzY3JpcHRvciAmIDB4ODApKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKChldmVudGRlc2NyaXB0b3IgJiAweDgwKSAhPSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBjb25zb2xlLmxvZygnZGVsYXkgY291bnQnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIE5vdyB3ZSBuZWVkIHRvIHJlYWQgdGhlIHRpbWUgY29kZTpcbiAgICAgICAgICAgICAgICBpZiAoIWhpdFNjb3JlRW5kKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKCdyZWFkIHRpbWUgY29kZScpO1xuICAgICAgICAgICAgICAgICAgICB0aW1lZGVsYXkgPSAwO1xuICAgICAgICAgICAgICAgICAgICAvLyBkZWxheUNvdW50ZXIgPSAwO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKDs7KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB3b3JraW5nID0gZ2V0TXVzQnl0ZTgoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGRlbGF5Q291bnRlciArPSAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGltZWRlbGF5ID0gdGltZWRlbGF5ICogMTI4ICsgKHdvcmtpbmcgJiAweDdmKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICgod29ya2luZyAmIDB4ODApID09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyBjb25zb2xlLmxvZygnZGVsYXkgY291bnQ6ICcrZGVsYXlDb3VudGVyICsgJyB0aW1lIGRlbGF5OiAnICsgdGltZWRlbGF5KVxuICAgICAgICAgICAgICAgICAgICBxdWV1ZWR0aW1lICs9IHRpbWVkZWxheTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBjb25zb2xlLmxvZyhgQ29udmVydGVkICcke2x1bXBJZH0nIGZyb20gTVVTIHRvIE1JREkgKFdBRDogJyR7d2FkSWR9JykuYCk7XG4gICAgICAgICAgICAvLyBFbmQgb2YgdHJhY2tcbiAgICAgICAgICAgIHdyaXRlRW5kVHJhY2soKTtcblxuICAgICAgICAgICAgY29uZmlybVdyaXRlKCk7XG5cbiAgICAgICAgICAgIC8vIFdyaXRlIHRoZSB0cmFjayBzaXplIGludG8gdGhlIHN0cmVhbVxuICAgICAgICAgICAgb3V0cHV0RGF0YVZpZXcuc2V0VWludDgoXG4gICAgICAgICAgICAgICAgTUlESV9UUkFDS0xFTkdUSF9PRlMgKyAwLFxuICAgICAgICAgICAgICAgICh0cmFja3NpemUgPj4gMjQpICYgMHhmZlxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIG91dHB1dERhdGFWaWV3LnNldFVpbnQ4KFxuICAgICAgICAgICAgICAgIE1JRElfVFJBQ0tMRU5HVEhfT0ZTICsgMSxcbiAgICAgICAgICAgICAgICAodHJhY2tzaXplID4+IDE2KSAmIDB4ZmZcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBvdXRwdXREYXRhVmlldy5zZXRVaW50OChcbiAgICAgICAgICAgICAgICBNSURJX1RSQUNLTEVOR1RIX09GUyArIDIsXG4gICAgICAgICAgICAgICAgKHRyYWNrc2l6ZSA+PiA4KSAmIDB4ZmZcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBvdXRwdXREYXRhVmlldy5zZXRVaW50OChNSURJX1RSQUNLTEVOR1RIX09GUyArIDMsIHRyYWNrc2l6ZSAmIDB4ZmYpO1xuXG4gICAgICAgICAgICByZXR1cm4gb3V0cHV0RGF0YVZpZXcuYnVmZmVyO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgbWlkaSA9IGNvbnZlcnRNdXNUb01pZGkoZGF0YSk7XG4gICAgICAgIGlmICghbWlkaSkge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICAgICBgRmFpbGVkIHRvIGNvbnZlcnQgJyR7dHlwZX0vJHtuYW1lfScgZnJvbSBNVVMgdG8gTUlESSAoV0FEOiAnJHt3YWRJZH0nKS5gLFxuICAgICAgICAgICAgICAgIHsgbXVzRGF0YVBvc2l0aW9uIH1cbiAgICAgICAgICAgICk7XG4gICAgICAgIH1cblxuICAgICAgICBzZXRDYWNoZUl0ZW1Bc0Jsb2IoeyBjYWNoZUlkOiB3YWRJZCwgcmVxdWVzdFVSTCwgcmVzcG9uc2VEYXRhOiBtaWRpIH0pO1xuXG4gICAgICAgIHBvc3RNZXNzYWdlKHtcbiAgICAgICAgICAgIHdhZElkLFxuICAgICAgICAgICAgbHVtcElkOiBuYW1lLFxuICAgICAgICAgICAgbHVtcFR5cGU6IHR5cGUsXG4gICAgICAgICAgICBvdXRwdXQ6IHJlcXVlc3RVUkxcbiAgICAgICAgfSk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcignU29tZXRoaW5nIGJhZCBoYXBwZW5lZCBpbiBtaWRpQ29udmVydGVyLicsIHsgZXJyb3IgfSk7XG4gICAgfVxufTtcbiJdLCJtYXBwaW5ncyI6Ijs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFtQkE7QUFTQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUxBO0FBUUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBT0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBRUE7QUFFQTtBQUVBO0FBU0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUVBO0FBRUE7QUFhQTtBQUVBO0FBRUE7QUFJQTtBQVFBO0FBRUE7QUFFQTtBQUVBO0FBQ0E7QUFFQTtBQUlBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFFQTtBQUVBO0FBRUE7QUFSQTtBQVlBO0FBRUE7QUFDQTtBQUVBO0FBRUE7QUFDQTtBQUVBO0FBRUE7QUFFQTtBQUdBO0FBS0E7QUFHQTtBQUVBO0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFFQTtBQUNBO0FBRUE7QUFFQTtBQUVBO0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQU1BO0FBQ0E7QUFDQTtBQUtBO0FBSUE7QUFFQTtBQUVBO0FBRUE7QUFJQTtBQW5CQTtBQXlCQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFrQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBRUE7QUFFQTtBQUVBO0FBRUE7QUFFQTtBQUVBO0FBRUE7QUFFQTtBQUVBO0FBRUE7QUFFQTtBQUVBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSkE7QUFPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSkE7QUFPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSkE7QUFPQTtBQUVBO0FBRUE7QUFFQTtBQUVBO0FBRUE7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUZBO0FBS0E7QUFDQTtBQUZBO0FBS0E7QUFDQTtBQUZBO0FBS0E7QUFDQTtBQUZBO0FBS0E7QUFDQTtBQUZBO0FBbkJBO0FBeUJBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFGQTtBQUtBO0FBQ0E7QUFGQTtBQVBBO0FBYUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQVRBO0FBWUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBUkE7QUFXQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQVRBO0FBWUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBUkE7QUFXQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUZBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUVBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUVBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBbEJBO0FBekZBO0FBZ0hBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUZBO0FBS0E7QUFDQTtBQUZBO0FBS0E7QUFDQTtBQUZBO0FBS0E7QUFDQTtBQUZBO0FBS0E7QUFDQTtBQUZBO0FBS0E7QUFDQTtBQUZBO0FBS0E7QUFDQTtBQUZBO0FBS0E7QUFDQTtBQUNBO0FBSEE7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUhBO0FBTUE7QUFDQTtBQUNBO0FBSEE7QUFNQTtBQUNBO0FBQ0E7QUFIQTtBQU1BO0FBQ0E7QUFDQTtBQUhBO0FBTUE7QUFDQTtBQUNBO0FBSEE7QUF6REE7QUFnRUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBRUE7QUFDQTtBQUNBO0FBSEE7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUhBO0FBTUE7QUFDQTtBQUNBO0FBSEE7QUFNQTtBQUNBO0FBQ0E7QUFIQTtBQU1BO0FBQ0E7QUFDQTtBQUhBO0FBTUE7QUFDQTtBQUNBO0FBSEE7QUFLQTtBQUFBO0FBQ0E7QUFBQTtBQXRDQTtBQWpFQTtBQTRHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSEE7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUhBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFIQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBSEE7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUhBO0FBckJBO0FBNEJBO0FBQ0E7QUFDQTtBQW1RQTtBQVdBOzs7Ozs7Ozs7Ozs7QUNwNUJBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUVBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFFQTtBQUZBO0FBQUE7QUFDQTtBQURBO0FBR0E7QUFDQTtBQUpBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFXQTtBQUVBO0FBQUE7QUFiQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUFBO0FBbUJBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFFQTtBQUZBO0FBQUE7QUFDQTtBQURBO0FBR0E7QUFDQTtBQUpBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFXQTtBQUVBO0FBQUE7QUFiQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUFBO0FBbUJBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFFQTtBQUZBO0FBQUE7QUFDQTtBQURBO0FBR0E7QUFDQTtBQUpBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFXQTtBQUVBO0FBQUE7QUFiQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUFBO0FBbUJBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFFQTtBQUZBO0FBQUE7QUFDQTtBQURBO0FBR0E7QUFDQTtBQUpBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFXQTtBQUVBO0FBQUE7QUFiQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUFBO0FBbUJBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBS0E7QUFFQTtBQUFBO0FBUEE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFBQTtBQWFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBRUE7QUFGQTtBQUFBO0FBR0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFKQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFRQTtBQUFBO0FBQUE7QUFSQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUFBOztBQzNFQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///4\n")}]);